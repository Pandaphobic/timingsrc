{"version":3,"file":"timingsrc-min-v3.js","sources":["../../v3/util/utils.js","../../v3/util/endpoint.js","../../v3/util/interval.js","../../v3/util/motionutils.js","../../v3/util/eventify.js","../../v3/util/timeout.js","../../v3/timingobject/masterclock.js","../../v3/timingobject/internalprovider.js","../../v3/timingobject/externalprovider.js","../../v3/timingobject/timingobject.js","../../v3/timingobject/skewconverter.js","../../v3/timingobject/delayconverter.js","../../v3/timingobject/scaleconverter.js","../../v3/timingobject/loopconverter.js","../../v3/timingobject/rangeconverter.js","../../v3/timingobject/timeshiftconverter.js","../../v3/util/binarysearch.js","../../v3/sequencing/dataset.js","../../v3/sequencing/schedule.js","../../v3/sequencing/basesequencer.js","../../v3/sequencing/singlesequencer.js","../../v3/sequencing/doublesequencer.js","../../v3/index.js"],"sourcesContent":["/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/* Set Comparison */\nexport function eqSet(as, bs) {\n    return as.size === bs.size && all(isIn(bs), as);\n}\n\nexport function all(pred, as) {\n    for (var a of as) if (!pred(a)) return false;\n    return true;\n}\n\nexport function isIn(as) {\n    return function (a) {\n        return as.has(a);\n    };\n}\n\n/*\n    get the difference of two Maps\n    key in a but not in b\n*/\nexport const map_difference = function (a, b) {\n    if (a.size == 0) {\n        return new Map();\n    } else if (b.size == 0) {\n        return a;\n    } else {\n        return new Map([...a].filter(function ([key, value]) {\n            return !b.has(key)\n        }));\n    }\n};\n\n/*\n    get the intersection of two Maps\n    key in a and b\n*/\nexport const map_intersect = function (a, b) {\n    [a, b] = (a.size <= b.size) ? [a,b] : [b,a];\n    if (a.size == 0) {\n        // No intersect\n        return new Map();\n    }\n    return new Map([...a].filter(function ([key, value]) {\n        return b.has(key)\n    }));\n};\n\nexport function divmod (n, d) {\n    let r = n % d;\n    let q = (n-r)/d;\n    return [q, r];\n}\n\n\nexport function isIterable(obj) {\n    // checks for null and undefined\n    if (obj == null) {\n        return false;\n    }\n    return typeof obj[Symbol.iterator] === 'function';\n}\n\n/*\n    effective concatenation of multiple arrays\n    - order - if true preserves ordering of input arrays\n            - else sorts input arrays (longest first)\n            - default false is more effective\n    - copy  - if true leaves input arrays unchanged, copy\n              values into new array\n            - if false copies remainder arrays into the first\n              array\n            - default false is more effective\n*/\nexport function array_concat(arrays, options = {}) {\n    let {copy=false, order=false} = options;\n    if (arrays.length == 0) {\n        return [];\n    }\n    if (arrays.length == 1) {\n        return arrays[0];\n    }\n    let total_len = arrays.reduce((acc, cur) => acc + cur.length, 0);\n    // order\n    if (!order) {\n        // sort arrays according to length - longest first\n        arrays.sort((a, b) => b.length - a.length);\n    }\n    // copy\n    let first = (copy) ? [] : arrays.shift();\n    let start = first.length;\n    // reserve memory total length\n    first.length = total_len;\n    // fill up first with entries from other arrays\n    let end, len;\n    for (let arr of arrays) {\n        len = arr.length;\n        end = start + len;\n        for (let i=0; i<len; i++) {\n            first[start + i] = arr[i]\n        }\n        start = end;\n    }\n    return first;\n};\n\n/*\n    default object equals\n*/\nexport function object_equals(a, b) {\n    // Create arrays of property names\n    let aProps = Object.getOwnPropertyNames(a);\n    let bProps = Object.getOwnPropertyNames(b);\n    let len = aProps.length;\n    let propName;\n    // If properties lenght is different => not equal\n    if (aProps.length != bProps.length) {\n        return false;\n    }\n    for (let i=0; i<len; i++) {\n        propName = aProps[i];\n        // If property values are not equal => not equal\n        if (a[propName] !== b[propName]) {\n            return false;\n        }\n    }\n    // equal\n    return true;\n}\n\n\n/* document readypromise */\nexport const docready = new Promise(function(resolve) {\n    if (document.readyState === 'complete') {\n        resolve();\n    } else {\n        let onReady = function () {\n            resolve();\n            document.removeEventListener('DOMContentLoaded', onReady, true);\n            window.removeEventListener('load', onReady, true);\n        };\n        document.addEventListener('DOMContentLoaded', onReady, true);\n        window.addEventListener('load', onReady, true);\n    }\n});\n\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nconst isNumber = function(n) {\n\tlet N = parseFloat(n);\n    return (n===N && !isNaN(N));\n};\n\n\n/*********************************************************\n\nENDPOINT\n\nUtilities for interval endpoints comparison\n\n**********************************************************/\n\n/*\n\tendpoint modes - in endpoint order\n\tendpoint order\n\tp), [p, [p], p], (p\n*/\nconst MODE_RIGHT_OPEN = 0;\nconst MODE_LEFT_CLOSED = 1;\nconst MODE_SINGULAR = 2;\nconst MODE_RIGHT_CLOSED = 3;\nconst MODE_LEFT_OPEN = 4;\n\n// create endpoint\nfunction create(val, right, closed, singular) {\n\t// make sure infinity endpoints are legal\n\tif (val == Infinity) {\n\t\tif (right == false || closed == false) {\n\t\t\tthrow new Error(\"Infinity endpoint must be right-closed or singular\");\n\t\t}\n\t}\n\tif (val == -Infinity) {\n\t\tif (right == true || closed == false) {\n\t\t\tthrow new Error(\"-Infinity endpoint must be left-closed or singular\")\n\t\t}\n\t}\n\treturn [val, right, closed, singular];\n}\n\n\n/*\n\tresolve endpoint mode\n*/\nfunction get_mode(e) {\n\t// if right, closed is given\n\t// use that instead of singular\n\tlet [val, right, closed, singular] = e;\n\tif (right == undefined) {\n\t\treturn MODE_SINGULAR;\n\t} else if (right) {\n\t\tif (closed) {\n\t\t\treturn MODE_RIGHT_CLOSED;\n\t\t} else {\n\t\t\treturn MODE_RIGHT_OPEN;\n\t\t}\n\t} else {\n\t\tif (closed) {\n\t\t\treturn MODE_LEFT_CLOSED;\n\t\t} else {\n\t\t\treturn MODE_LEFT_OPEN;\n\t\t}\n\t}\n}\n\n/*\n\tget order\n\n\tgiven two endpoints\n\treturn two numbers representing their order\n\n\talso accepts regular numbers as endpoints\n\tregular number are represented as singular endpoints\n\n\tfor endpoint values that are not\n\tequal, these values convey order directly,\n\totherwise endpoint mode numbers 0-4 are returned\n\n\tparameters are either\n\t- point: Number\n\tor,\n\t- endpoint: [\n\t\tvalue (number),\n\t\tright (bool),\n\t\tclosed (bool),\n\t\tsingular (bool)\n\t  ]\n*/\n\nfunction get_order(e1, e2) {\n\t// support plain numbers (not endpoints)\n\tif (e1.length === undefined) {\n\t\tif (!isNumber(e1)) {\n\t\t\tthrow new Error(\"e1 not a number\", e1);\n\t\t}\n\t\te1 = create(e1, undefined, undefined, true);\n\t}\n\tif (e2.length === undefined) {\n\t\tif (!isNumber(e2)) {\n\t\t\tthrow new Error(\"e2 not a number\", e2);\n\t\t}\n\t\te2 = create(e2, undefined, undefined, true);\n\t}\n\tif (e1[0] != e2[0]) {\n\t\t// different values\n\t\treturn [e1[0], e2[0]];\n\t} else {\n\t\t// equal values\n\t\treturn [get_mode(e1), get_mode(e2)];\n\t}\n}\n\n/*\n\treturn true if e1 is ordered before e2\n\tfalse if equal\n*/\n\nfunction leftof(e1, e2) {\n\tlet [order1, order2] = get_order(e1, e2);\n\treturn (order1 < order2);\n}\n\n/*\n\treturn true if e1 is ordered after e2\n\tfalse is equal\n*/\n\nfunction rightof(e1, e2) {\n\tlet [order1, order2] = get_order(e1, e2);\n\treturn (order1 > order2);\n}\n\n/*\n\treturn true if e1 is ordered equal to e2\n*/\n\nfunction equals(e1, e2) {\n\tlet [order1, order2] = get_order(e1, e2);\n\treturn (order1 == order2);\n}\n\n/*\n\treturn -1 if ordering e1, e2 is correct\n\treturn 0 if e1 and e2 is equal\n\treturn 1 if ordering e1, e2 is incorrect\n*/\n\nfunction cmp(e1, e2) {\n\tlet [order1, order2] = get_order(e1, e2);\n\tlet diff = order1 - order2;\n\tif (diff == 0) return 0;\n\treturn (diff > 0) ? 1 : -1;\n}\n\n\nfunction min(e1, e2) {\n    return (cmp(e1, e2) <= 0) ? e1 : e2;\n}\n\n\nfunction max(e1, e2) {\n    return (cmp(e1, e2) <= 0) ? e2 : e1;\n}\n\n\n/*\n\thuman friendly endpoint representation\n*/\nfunction toString(e) {\n\tif (e.length === undefined) {\n\t\treturn e.toString();\n\t} else {\n\t\tlet mode = get_mode(e);\n\t\tlet val = e[0];\n\t\tif (val == Infinity || val == -Infinity) {\n\t\t\tval = \"--\";\n\t\t}\n\t\tif (mode == MODE_RIGHT_OPEN) {\n\t\t\treturn `${val})`\n\t\t} else if (mode == MODE_LEFT_CLOSED) {\n\t\t\treturn `[${val}`\n\t\t} else if (mode == MODE_SINGULAR){\n\t\t\treturn `[${val}]`\n\t\t} else if (mode == MODE_RIGHT_CLOSED) {\n\t\t\treturn `${val}]`\n\t\t} else if (mode == MODE_LEFT_OPEN) {\n\t\t\treturn `(${val}`\n\t\t}\n\t}\n}\n\n\nexport default {\n\tcmp,\n\ttoString,\n\tequals,\n\trightof,\n\tleftof,\n\tcreate,\n\tmin,\n\tmax\n};\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nimport endpoint from './endpoint.js';\n\n\nconst isNumber = function(n) {\n\tlet N = parseFloat(n);\n    return (n===N && !isNaN(N));\n};\n\n/*********************************************************\nINTERVAL ERROR\n**********************************************************/\n\nclass IntervalError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name == \"IntervalError\";\n\t}\n};\n\n\n/*********************************************************\nINTERVAL\n**********************************************************/\n\n// Interval Relations\nconst Relation = Object.freeze({\n\tOUTSIDE_LEFT: 64,  \t// 0b1000000\n\tOVERLAP_LEFT: 32,  \t// 0b0100000\n\tCOVERED: 16,\t\t// 0b0010000\n\tEQUALS: 8,\t\t\t// 0b0001000\n\tCOVERS: 4,\t\t\t// 0b0000100\n\tOVERLAP_RIGHT: 2,\t// 0b0000010\n\tOUTSIDE_RIGHT: 1\t// 0b0000001\n});\n\n/*\n    Masks for Interval matching\n*/\nconst MATCH_OUTSIDE = Relation.OUTSIDE_LEFT + Relation.OUTSIDE_RIGHT;\nconst MATCH_INSIDE = Relation.EQUALS + Relation.COVERED;\nconst MATCH_OVERLAP = MATCH_INSIDE +\n\tRelation.OVERLAP_LEFT + Relation.OVERLAP_RIGHT;\nconst MATCH_COVERS = MATCH_OVERLAP + Relation.COVERS;\nconst MATCH_ALL = MATCH_COVERS + MATCH_OUTSIDE;\n\n\n/*********************************************************\nINTERVAL\n**********************************************************/\n\nclass Interval {\n\n\n\tstatic fromEndpoints(endpointLow, endpointHigh) {\n\t\tlet [low, low_right, low_closed, low_singular] = endpointLow;\n\t\tlet [high, high_right, high_closed, high_singular] = endpointHigh;\n\t\tif (low_right) {\n\t\t\tthrow new IntervalError(\"illegal endpointLow - bracket must be left\");\n\t\t}\n\t\tif (!high_right) {\n\t\t\tthrow new IntervalError(\"illegal endpointHigh - bracket must be right\");\n\t\t}\n\t\treturn new Interval(low, high, low_closed, high_closed);\n\t};\n\n\n\tstatic Match = Object.freeze({\n\t\tOUTSIDE: MATCH_OUTSIDE,\n\t\tINSIDE: MATCH_INSIDE,\n\t\tOVERLAP: MATCH_OVERLAP,\n\t\tCOVERS: MATCH_COVERS,\n\t\tALL: MATCH_ALL\n\t});\n\n\n\tconstructor (low, high, lowInclude, highInclude) {\n\t\tvar lowIsNumber = isNumber(low);\n\t\tvar highIsNumber = isNumber(high);\n\t\t// new Interval(3.0) defines singular - low === high\n\t\tif (lowIsNumber && high === undefined) high = low;\n\t\tif (!isNumber(low)) throw new IntervalError(\"low not a number\");\n\t\tif (!isNumber(high)) throw new IntervalError(\"high not a number\");\n\t\tif (low > high) throw new IntervalError(\"low > high\");\n\t\tif (low === high) {\n\t\t\tlowInclude = true;\n\t\t\thighInclude = true;\n\t\t}\n\t\tif (low === -Infinity) lowInclude = true;\n\t\tif (high === Infinity) highInclude = true;\n\t\tif (lowInclude === undefined) lowInclude = true;\n\t\tif (highInclude === undefined) highInclude = false;\n\t\tif (typeof lowInclude !== \"boolean\") throw new IntervalError(\"lowInclude not boolean\");\n\t\tif (typeof highInclude !== \"boolean\") throw new IntervalError(\"highInclude not boolean\");\n\t\tthis.low = low;\n\t\tthis.high = high;\n\t\tthis.lowInclude = lowInclude;\n\t\tthis.highInclude = highInclude;\n\t\tthis.length = this.high - this.low;\n\t\tthis.singular = (this.low === this.high);\n\t\tthis.finite = (isFinite(this.low) && isFinite(this.high));\n\n\t\t/*\n\t\t\tAccessors for full endpoint representationo\n\t\t\t[value (number), right (bool), closed (bool)]\n\n\t\t\t- use with inside(endpoint, interval)\n\t\t*/\n\t\tthis.endpointLow = endpoint.create(this.low, false, this.lowInclude, this.singular);\n\t\tthis.endpointHigh = endpoint.create(this.high, true, this.highInclude, this.singular);\n\t}\n\n\ttoString () {\n\t\tconst toString = endpoint.toString;\n\t\tif (this.singular) {\n\t\t\tlet p = this.endpointLow[0];\n\t\t\treturn `[${p}]`;\n\t\t} else {\n\t\t\tlet low = endpoint.toString(this.endpointLow);\n\t\t\tlet high = endpoint.toString(this.endpointHigh);\n\t\t\treturn `${low},${high}`;\n\t\t}\n\t};\n\n\tcovers_endpoint (p) {\n\t\tlet leftof = endpoint.leftof(p, this.endpointLow);\n\t\tlet rightof = endpoint.rightof(p, this.endpointHigh);\n\t\treturn !leftof && !rightof;\n\t}\n\n\tcompare (other) {\n\t\treturn compare(this, other);\n\t}\n\n\tequals (other) {\n\t\treturn compare(this, other) == Relation.EQUALS;\n\t}\n\n\tcovered (other) {\n\t\treturn compare(this, other) == Relation.COVERED;\n\t}\n\n\tcovers (other) {\n\t\treturn compare(this, other) == Relation.COVERS;\n\t}\n\n\t/*\n\t\tdefault mode - all except outside\n\t\t2+4+8+16+32 = 62\n\t*/\n\tmatch (other, mask=MATCH_COVERS) {\n\t\tlet relation = compare(this, other);\n\t\treturn Boolean(mask & relation);\n\t}\n}\n\n\n\n/*********************************************************\nCOMPARE INTERVALS\n**********************************************************\n\ncompare (a, b)\nparam a Interval\nparam b Interval\nreturns IntervalRelation\n\ncompares interval b to interval a\ne.g. return value COVERED reads b is covered by a.\n\ncmp_1 = endpoint_compare(b_low, a_low);\ncmp_2 = endpoint_compare(b_high, a_high);\n\nkey = 10*cmp_1 + cmp_2\n\ncmp_1  cmp_2  key  relation\n=====  =====  ===  ============================\n-1     -1     -11  OUTSIDE_LEFT, PARTIAL_LEFT\n-1 \t   0      -10  COVERS\n-1     1       -9  COVERS\n0\t   -1      -1  COVERED\n0      0        0  EQUAL\n0 \t   1        1  COVERS\n1      -1       9  COVERED\n1 \t   0       10  COVERED\n1 \t   1       11  OUTSIDE_RIGHT, OVERLAP_RIGHT\n=====  =====  ===  ============================\n\n**********************************************************/\n\n\n\nfunction compare(a, b) {\n\tif (! a instanceof Interval) {\n\t\t// could be a number\n\t\tif (isNumber(a)) {\n\t\t\ta = new Interval(a);\n\t\t} else {\n\t\t\tthrow new IntervalError(\"a not interval\", a);\n\t\t}\n\t}\n\tif (! b instanceof Interval) {\n\t\t// could be a number\n\t\tif (isNumber(b)) {\n\t\t\tb = new Interval(b);\n\t\t} else {\n\t\t\tthrow new IntervalError(\"b not interval\", b);\n\t\t}\n\t}\n\n\tlet cmp_1 = endpoint.cmp(a.endpointLow, b.endpointLow);\n\tlet cmp_2 = endpoint.cmp(a.endpointHigh, b.endpointHigh);\n\tlet key = cmp_1*10 + cmp_2;\n\n\tif (key == 11) {\n\t\t// OUTSIDE_LEFT or PARTIAL_LEFT\n\t\tif (endpoint.leftof(b.endpointHigh, a.endpointLow)) {\n\t\t\treturn Relation.OUTSIDE_RIGHT;\n\t\t} else {\n\t\t\treturn Relation.OVERLAP_RIGHT;\n\t\t}\n\t} else if ([-1, 9, 10].includes(key)) {\n\t\treturn Relation.COVERED;\n\t} else if ([1, -9, -10].includes(key)) {\n\t\treturn Relation.COVERS;\n\t} else if (key == 0) {\n\t\treturn Relation.EQUALS;\n\t} else {\n\t\t// key == -11\n\t\t// OUTSIDE_RIGHT, PARTIAL_RIGHT\n\t\tif (endpoint.rightof(b.endpointLow, a.endpointHigh)) {\n\t\t\treturn Relation.OUTSIDE_LEFT;\n\t\t} else {\n\t\t\treturn Relation.OVERLAP_LEFT;\n\t\t}\n\t}\n}\n\n/*********************************************************\nCOMPARE INTERVALS BY ENDPOINT\n**********************************************************\n\ncmp functions for sorting intervals (ascending) based on\nendpoint low or high\n\nuse with array.sort()\n\n**********************************************************/\n\nfunction _make_interval_cmp(low) {\n\treturn function cmp (a, b) {\n\t\tlet e1, e2;\n\t\tif (low) {\n\t\t\te1 = [a.low, false, a.lowInclude, a.singular];\n\t\t\te2 = [b.low, false, b.lowInclude, a.singular];\n\t\t} else {\n\t\t\te1 = [a.high, true, a.highInclude, a.singular];\n\t\t\te2 = [b.high, true, b.highInclude, a.singular];\n\t\t}\n\t\treturn endpoint.cmp(e1, e2);\n\t}\n}\n\n/*\n\tAdd static variables to Interval class.\n*/\nInterval.Relation = Relation;\nInterval.cmpLow = _make_interval_cmp(true);\nInterval.cmpHigh = _make_interval_cmp(false);\n\n/*\n\tPossibility for more interval methods such as union, intersection,\n*/\n\nexport default Interval;\n\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport endpoint from './endpoint.js';\nimport Interval from './interval.js';\n\n\n// sort func\nconst cmp = function (a, b) {return a - b;};\n\n/*******************************************************************\n BASIC\n*******************************************************************/\n\nexport function equalVectors(vector_a, vector_b) {\n    let pos = vector_a.position == vector_b.position;\n    let vel = vector_a.velocity == vector_b.velocity;\n    let acc = vector_a.acceleration == vector_b.acceleration;\n    let ts = vector_a.timestamp == vector_b.timestamp;\n    return pos && vel && acc && ts;\n};\n\n\nexport function copyVector(vector) {\n    return {\n        position: vector.position,\n        velocity: vector.velocity,\n        acceleration: vector.acceleration,\n        timestamp: vector.timestamp\n    }\n};\n\n/*\n    Calculate vector snapshot for motion defined by vector at time ts\n\n    vector: [p0,v0,a0,t0]\n    t0 and ts are absolute time from same clock, in seconds\n*/\n\nexport function calculateVector(vector, ts) {\n\tif (ts === undefined) {\n\t    throw new Error (\"no ts provided for calculateVector\");\n\t}\n\tconst deltaSec = ts - vector.timestamp;\n\treturn {\n\t\tposition : vector.position + vector.velocity*deltaSec + 0.5*vector.acceleration*deltaSec*deltaSec,\n\t\tvelocity : vector.velocity + vector.acceleration*deltaSec,\n\t\tacceleration : vector.acceleration,\n\t\ttimestamp : ts\n\t};\n};\n\n\n/*\n    Calculate direction of motion at time ts\n    1 : forwards, -1 : backwards: 0, no movement\n*/\nexport function calculateDirection(vector, ts) {\n    /*\n      Given initial vector calculate direction of motion at time t\n      (Result is valid only if (t > vector[T]))\n      Return Forwards:1, Backwards -1 or No-direction (i.e. no-motion) 0.\n      If t is undefined - t is assumed to be now.\n    */\n    let freshVector;\n    if (ts == undefined) {\n        freshVector = vector;\n    } else {\n        freshVector = calculateVector(vector, ts);\n    }\n    // check velocity\n    let direction = cmp(freshVector.velocity, 0.0);\n    if (direction === 0) {\n        // check acceleration\n        direction = cmp(vector.acceleration, 0.0);\n    }\n    return direction;\n};\n\n\n/*\n    isMoving\n\n    returns true if motion is moving else false\n*/\nexport function isMoving(vector) {\n    return (vector.velocity !== 0.0 || vector.acceleration !== 0.0);\n};\n\n\n/*******************************************************************\n RANGE\n*******************************************************************/\n\n//\tRANGE STATE is used for managing/detecting range violations.\nexport const RangeState = Object.freeze({\n    INIT : \"init\",\n    INSIDE: \"inside\",\n    OUTSIDE_LOW: \"outsidelow\",\n    OUTSIDE_HIGH: \"outsidehigh\"\n});\n\n/*\n\tA snapshot vector is checked with respect to range,\n\tcalclulates correct RangeState (i.e. INSIDE|OUTSIDE)\n*/\nexport function correctRangeState(vector, range) {\n    const {position: p, velocity: v, acceleration: a} = vector;\n\tif (p > range[1]) return RangeState.OUTSIDE_HIGH;\n\tif (p < range[0]) return RangeState.OUTSIDE_LOW;\n\t// corner cases\n\tif (p === range[1]) {\n\t\tif (v > 0.0) return RangeState.OUTSIDE_HIGH;\n\t\tif (v === 0.0 && a > 0.0) return RangeState.OUTSIDE_HIGH;\n\t} else if (p === range[0]) {\n\t    if (v < 0.0) return RangeState.OUTSIDE_LOW;\n\t    if (v == 0.0 && a < 0.0) return RangeState.OUTSIDE_HIGH;\n\t}\n\treturn RangeState.INSIDE;\n};\n\n/*\n\n\tA snapshot vector is checked with respect to range.\n\tReturns vector corrected for range violations, or input vector unchanged.\n*/\nexport function checkRange(vector, range) {\n\tconst state = correctRangeState(vector, range);\n\tif (state !== RangeState.INSIDE) {\n\t\t// protect from range violation\n\t\tvector.velocity = 0.0;\n\t\tvector.acceleration = 0.0;\n\t\tif (state === RangeState.OUTSIDE_HIGH) {\n\t\t\tvector.position = range[1];\n\t\t} else vector.position = range[0];\n\t}\n\treturn vector;\n};\n\n\n/*\n    Return tsEndpoint of (first) range intersect if any.\n*/\nexport function rangeIntersect(vector, range) {\n    let t0 = vector.timestamp;\n    // Time delta to hit rangeLeft\n    let deltaLeft = calculateMinPositiveRealSolution(vector, range[0]);\n    // Time delta to hit rangeRight\n    let deltaRight = calculateMinPositiveRealSolution(vector, range[1]);\n    // Pick the appropriate solution\n    if (deltaLeft !== undefined && deltaRight !== undefined) {\n        if (deltaLeft < deltaRight) {\n            return [t0 + deltaLeft, range[0]];\n        }\n        else\n            return [t0 + deltaRight, range[1]];\n    }\n    else if (deltaLeft !== undefined)\n        return [t0 + deltaLeft, range[0]];\n    else if (deltaRight !== undefined)\n        return [t0 + deltaRight, range[1]];\n    else return [undefined, undefined];\n}\n\n\n/*******************************************************************\n EQUATIONS\n*******************************************************************/\n\n/*\n    hasRealSolution\n\n    Given motion determined from p,v,a,t.\n    Determine if equation p(t) = p + vt + 0.5at^2 = x\n    has solutions for some real number t.\n*/\n\nfunction hasRealSolution (p,v,a,x) {\n\tif ((Math.pow(v,2) - 2*a*(p-x)) >= 0.0) return true;\n\telse return false;\n};\n\n\n/*\n    calculateRealSolution\n\n    Given motion determined from p,v,a,t.\n    Determine if equation p(t) = p + vt + 0.5at^2 = x\n    has solutions for some real number t.\n    Calculate and return real solutions, in ascending order.\n*/\n\nfunction calculateRealSolutions(p,v,a,x) {\n\t// Constant Position\n\tif (a === 0.0 && v === 0.0) {\n\t    if (p != x) return [];\n\t    else return [0.0];\n\t}\n\t// Constant non-zero Velocity\n\tif (a === 0.0) return [(x-p)/v];\n\t// Constant Acceleration\n\tif (hasRealSolution(p,v,a,x) === false) return [];\n\t// Exactly one solution\n\tconst discriminant = v*v - 2*a*(p-x);\n\tif (discriminant === 0.0) {\n\t    return [-v/a];\n\t}\n\tconst sqrt = Math.sqrt(Math.pow(v,2) - 2*a*(p-x));\n\tconst d1 = (-v + sqrt)/a;\n\tconst d2 = (-v - sqrt)/a;\n\treturn [Math.min(d1,d2),Math.max(d1,d2)];\n};\n\n\n/*\n    calculatePositiveRealSolutions\n\n    Given motion determined from p,v,a,t.\n    Determine if equation p(t) = p + vt + 0.5at^2 = x\n    has solutions for some real number t.\n    Calculate and return positive real solutions, in ascending order.\n*/\n\nfunction calculatePositiveRealSolutions(p,v,a,x) {\n\tconst res = calculateRealSolutions(p,v,a,x);\n\tif (res.length === 0) return [];\n\telse if (res.length == 1) {\n\t    if (res[0] > 0.0) {\n\t\t\treturn [res[0]];\n\t    }\n\t    else return [];\n\t}\n\telse if (res.length == 2) {\n\t    if (res[1] < 0.0) return [];\n\t    if (res[0] > 0.0) return [res[0], res[1]];\n\t    if (res[1] > 0.0) return [res[1]];\n\t    return [];\n\t}\n\telse return [];\n};\n\n\n/*\n    calculateMinPositiveRealSolution\n\n    Given motion determined from p,v,a,t.\n    Determine if equation p(t) = p + vt + 0.5at^2 = x\n    has solutions for some real number t.\n    Calculate and return the least positive real solution.\n*/\nfunction calculateMinPositiveRealSolution(vector, x) {\n    const {position: p, velocity: v, acceleration: a} = vector;\n\tconst res = calculatePositiveRealSolutions(p,v,a,x);\n\tif (res.length === 0) {\n        return;\n    }\n\telse return res[0];\n};\n\n\n/*\n    calculateDelta\n\n\n    Given motion determined from p0,v0,a0 (initial conditions or snapshot),\n    Supply two posisions, posBefore < p0 < posAfter.\n    Calculate which of these positions will be reached first,\n    if any, by the movement described by the vector.\n    In addition, calculate when this position will be reached.\n    Result will be expressed as time delta relative to t0, if solution exists,\n    and a flag to indicate Before (false) or After (true)\n    Note: t1 == (delta + t0) is only guaranteed to be in the\n    future as long as the function\n    is evaluated at time t0 or immediately after.\n*/\nexport function calculateDelta(vector, range) {\n\t// Time delta to hit posBefore\n\tconst deltaBeforeSec = calculateMinPositiveRealSolution(vector, range[0]);\n\t// Time delta to hit posAfter\n\tconst deltaAfterSec = calculateMinPositiveRealSolution(vector, range[1]);\n\t// Pick the appropriate solution\n\tif (deltaBeforeSec !== undefined && deltaAfterSec !== undefined) {\n\t    if (deltaBeforeSec < deltaAfterSec)\n\t\t\treturn [deltaBeforeSec, range[0]];\n\t    else\n\t\t\treturn [deltaAfterSec, range[1]];\n\t}\n\telse if (deltaBeforeSec !== undefined)\n\t    return [deltaBeforeSec, range[0]];\n\telse if (deltaAfterSec !== undefined)\n\t    return [deltaAfterSec, range[1]];\n\telse return [undefined, undefined];\n};\n\n\n/*******************************************************************\n TIME_INTERVAL POS_INTERVAL\n*******************************************************************/\n\n/*\n    posInterval_from_timeInterval\n\n    given\n    - a time interval\n    - a vector describing motion within the time interval\n    figure out the smallest interval (of positions)\n    that covers all possible positions during the time interval\n*/\n\nexport function posInterval_from_timeInterval (timeInterval, vector) {\n\n    /*\n        no motion or singular time interval\n    */\n    if (!isMoving(vector) || timeInterval.singular) {\n        return new Interval(vector.position);\n    }\n\n    let t0 = timeInterval.low;\n    let t1 = timeInterval.high;\n    let t0_closed = timeInterval.lowInclude;\n    let t1_closed = timeInterval.highInclude;\n\n    let vector0 = calculateVector(vector, t0);\n    let p0 = vector0.position;\n    let v0 = vector0.velocity;\n    let a0 = vector0.acceleration;\n    let p1 = calculateVector(vector, t1).position;\n\n    if (a0 != 0) {\n\n        /*\n            motion, with acceleration\n\n            position over time is a parabola\n            figure out if extrema happens to occor within\n            timeInterval. If it does, extreme point is endpoint in\n            position Interval. p0 or p1 will be the other\n            interval endpoint.\n\n            I extreme point is not occuring within timeInterval,\n            interval endpoint will be p0 and p1.\n\n            general parabola\n            y = Ax*x + Bx + C\n            extrema (x,y) : x = - B/2A, y = -B*B/4A + C\n\n            where t0 <= t <= t1\n            p(t) = 0.5*a0*(t-t0)*(t-t0) + v0*(t-t0) + p0,\n\n            A = a0/2, B = v0, C = p0\n\n            extrema (t_extrema, p_extrema):\n            t_extrem = -v0/a0 + t0\n            p_extrem = -v0*v0/(2*a0) + p0\n\n        */\n        let t_extrem = -v0/a0 + t0;\n        if (timeInterval.covers_endpoint(t_extrem)) {\n            let p_extrem = -v0*v0/(2.0*a0) + p0;\n            // maximal point reached in time interval\n            if (a0 > 0.0) {\n                // p_extrem is minimum\n                // figure out if p0 or p1 is maximum\n                if (p0 < p1) {\n                    return new Interval(p_extrem, p1, true, t1_closed);\n                } else {\n                    return new Interval(p_extrem, p0, true, t0_closed);\n                }\n            } else {\n                // p_extrem is maximum\n                // figure out if p0 or p1 is minimum\n                if (p0 < p1) {\n                    return new Interval(p0, p_extrem, t0_closed, true);\n                } else {\n                    return new Interval(p1, p_extrem, t1_closed, true);\n                }\n            }\n        }\n    }\n\n    /*\n        Motion, with or without acceleration,\n        yet with no extreme points within interval\n\n        positition monotonic increasing (forward velocity)\n        or decreasing (backward velocity)\n\n        extrem positions are associated with p0 and p1.\n    */\n\n    if (p0 < p1) {\n        // forward\n        return new Interval(p0, p1, t0_closed, t1_closed);\n    } else {\n        // backward\n        return new Interval(p1, p0, t1_closed, t0_closed);\n    }\n}\n\n\n/*\n    time endpoint and pos endpoints.\n\n    time is always increasing even when position\n    is decreasing. When making a timeEndpoint from\n    a posEndpoin the right/left aspect of the endpoint\n    needs to be flipped.\n\n    ts - the value of the timeEndpoint, ie. the time when\n         motion will pass over posEndpoing\n    direction - direction of motion at time ts\n*/\n\nexport function timeEndpoint_from_posEndpoint(posEndpoint, ts, direction) {\n    let [pos, right, close, singular] = posEndpoint;\n    // flip right/left if direction is backwards\n    if (direction < 0 && right !== undefined) {\n        right = !right\n    }\n    return [ts, right, close, singular];\n}\n\n\n/*******************************************************************\n ENDPOINT EVENTS\n*******************************************************************/\n\n/*\n    endpointEvents\n\n    Given a motion and a set of endpoing, calculate when\n    the motion will pass by each endpoing.\n\n    Given\n    - timeInterval\n    - posInterval\n    - vector describing motion within timeInterval\n    - list of endpointItems\n\n    endpointItem\n    {\n        endpoint: [value, high, closed, singular],\n        cue: {\n            key: \"mykey\",\n            interval: new Interval(...),\n            data: {...}\n        }\n    }\n\n    Creates eventItem by adding to endpointItem\n    - tsEndpoint : timestamp endpoint (future) when motion will pass the endpoint\n    - direction: true if motion passes endpoint while moving forward\n\n    EventItems will be sorted by ts\n\n    Issue:\n\n        timeInterval [t0, t1)\n        posinterval [p0, p1)\n\n        Consider event at time t1 concerning endpoint p1)\n        This will be outside the timeInterval, but inside\n        the posInterval.\n\n        Conversely, it will be inside the next timeInterval,\n        but not the next posInterval.\n\n        This is a problem - like falling between chairs.\n\n        Resolve this by representing timestamps as endpoints too\n\n*/\n\nexport function endpointEvents (timeInterval, posInterval, vector, endpointItems) {\n\n    /*\n        no motion or singular time interval\n    */\n    if (timeInterval.singular) {\n        throw new Error(\"getEventItems: timeInterval is singular\");\n    }\n    if (!isMoving(vector)) {\n        throw new Error(\"getEventItems: no motion\")\n    }\n\n    let p0 = vector.position;\n    let v0 = vector.velocity;\n    let a0 = vector.acceleration;\n    let t0 = vector.timestamp;\n\n    let value, ts, deltas;\n    let tsEndpoint, direction;\n    let eventItems = [];\n\n    endpointItems.forEach(function(item) {\n        // check that endpoint is inside given posInterval\n        if (!posInterval.covers_endpoint(item.endpoint)) {\n            return;\n        }\n        value = item.endpoint[0];\n        // check if equation has any solutions\n        if (!hasRealSolution(p0, v0, a0, value)) {\n            return;\n        }\n        // find time when motion will pass value\n        // time delta is relative to t0\n        // could be both in history or future\n        deltas = calculateRealSolutions(p0,v0,a0, value);\n        // include any timestamp within the timeinterval\n        deltas.forEach(function(delta) {\n            ts = t0 + delta;\n            direction = calculateDirection(vector, ts);\n            tsEndpoint = timeEndpoint_from_posEndpoint(item.endpoint, ts, direction);\n            if (timeInterval.covers_endpoint(tsEndpoint)){\n                item.tsEndpoint = tsEndpoint;\n                item.direction = direction;\n                eventItems.push(item);\n            }\n        });\n    });\n\n    // sort eventItems according to tsEndpoints\n    const cmp = function (a,b) {\n        return endpoint.cmp(a.tsEndpoint, b.tsEndpoint);\n    };\n    eventItems.sort(cmp);\n    return eventItems;\n};\n\n\n/*******************************************************************\n MOTION TRANSITION\n*******************************************************************/\n\n/*\n    Figure the nature of the transition from one motion to another,\n    i.e. when old_vector is replaced by new_vector.\n\n    The time when this transition occured is given bey\n    new_vector.timestamp, by definition.\n\n    - was moving (boolean) - true if moving before change\n    - is moving (boolean) - true if moving after change\n    - pos changed (boolean) - true if position was changed instantaneously\n    - move changed (boolean) - true if movement was changed instantaneously\n\n    report changed in two independent aspects\n    - change in position (i.e. discontinuity in position)\n    - change in movement (i.e. starting, stopping, changed)\n\n    These are represented as\n    - PosDelta\n    - MoveDelta\n\n    return [PosDelta, MoveDelta]\n*/\n\n\nexport class MotionDelta {\n\n\n    static PosDelta = Object.freeze({\n        NOOP: 0,                // no change in position\n        CHANGE: 1               // change in position\n    });\n\n\n    static MoveDelta = Object.freeze({\n        NOOP: 0,                // no change in movement, not moving\n        NOOP_MOVING: 1,         // no change in movement, moving\n        START: 2,               // not moving -> moving\n        CHANGE: 3,              // keep moving, movement changed\n        STOP: 4                 // moving -> not moving\n    });\n\n    constructor (old_vector, new_vector) {\n        let ts = new_vector.timestamp;\n        let is_moving = isMoving(new_vector)\n        let init = (old_vector == undefined || old_vector.position == undefined);\n        const PosDelta = MotionDelta.PosDelta;\n        const MoveDelta = MotionDelta.MoveDelta;\n\n        if (init) {\n            /*\n                Possible to introduce\n                PosDelta.INIT here instead of PosDelta.CHANGE\n                Not sure if this is needed.\n            */\n            if (is_moving) {\n                this._mc = [PosDelta.CHANGE, MoveDelta.START];\n            } else {\n                this._mc = [PosDelta.CHANGE, MoveDelta.NOOP];\n            }\n        } else {\n            let was_moving = isMoving(old_vector);\n            let end_vector = calculateVector(old_vector, ts);\n            let start_vector = calculateVector(new_vector, ts);\n\n            // position change\n            let pos_changed = (end_vector.position != start_vector.position);\n            let pct = (pos_changed) ? PosDelta.CHANGE : PosDelta.NOOP;\n\n            // movement change\n            let mct;\n            if (was_moving && is_moving) {\n                let vel_changed = (end_vector.velocity != start_vector.velocity);\n                let acc_changed = (end_vector.acceleration != start_vector.acceleration);\n                let move_changed = (vel_changed || acc_changed);\n                if (move_changed) {\n                    mct = MoveDelta.CHANGE;\n                } else {\n                    mct = MoveDelta.NOOP_MOVING;\n                }\n            } else if (!was_moving && is_moving) {\n                mct = MoveDelta.START;\n            } else if (was_moving && !is_moving) {\n                mct = MoveDelta.STOP;\n            } else if (!was_moving && !is_moving) {\n                mct = MoveDelta.NOOP;\n            }\n            this._mc = [pct, mct];\n        }\n    }\n\n    get posDelta () {\n        return this._mc[0];\n    }\n\n    get moveDelta () {\n        return this._mc[1]\n    }\n\n    toString() {\n        const PosDelta = MotionDelta.PosDelta;\n        const MoveDelta = MotionDelta.MoveDelta;\n        let str = (this.posDelta == PosDelta.CHANGE) ? \"jump, \" : \"\";\n        if (this.moveDelta == MoveDelta.START) {\n            str += \"movement started\";\n        } else if (this.moveDelta == MoveDelta.CHANGE) {\n            str += \"movement changed\";\n        } else if (this.moveDelta == MoveDelta.STOP) {\n            str += \"movement stopped\";\n        } else if (this.moveDelta == MoveDelta.NOOP_MOVING) {\n            str += \"movement noop - moving\";\n        } else if (this.moveDelta == MoveDelta.NOOP) {\n            str += \"movement noop - not moving\";\n        }\n        return str;\n    }\n}\n\n\n// return module object\n/*\nexport default {\n    isMoving,\n    // equalVectors,\n    // copyVector,\n\tcalculateVector,\n\tcalculateDirection,\n\t// calculateMinPositiveRealSolution,\n\tcalculateDelta,\n\t// correctRangeState,\n\t// checkRange,\n\t// RangeState,\n    posInterval_from_timeInterval,\n    endpointEvents,\n    rangeIntersect,\n    MotionDelta\n};\n*/\n\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\n/*\n\tEvent\n\t- name: event name\n\t- publisher: the object which defined the event\n\t- init: true if the event suppports init events\n\t- subscriptions: subscriptins to this event\n\n*/\n\nclass Event {\n\n\tconstructor (publisher, name, options) {\n\t\toptions = options || {}\n\t\tthis.publisher = publisher;\n\t\tthis.name = name;\n\t\tthis.init = (options.init === undefined) ? false : options.init;\n\t\tthis.subscriptions = [];\n\t}\n\n\t/*\n\t\tsubscribe to event\n\t\t- subscriber: subscribing object\n\t\t- callback: callback function to invoke\n\t\t- options:\n\t\t\tinit: if true subscriber wants init events\n\t*/\n\tsubscribe (callback, options) {\n\t\tif (!callback || typeof callback !== \"function\") {\n\t\t\tthrow new Error(\"Callback not a function\", callback);\n\t\t}\n\t\tconst sub = new Subscription(this, callback, options);\n\t\tthis.subscriptions.push(sub);\n\t    // Initiate init callback for this subscription\n\t    if (this.init && sub.init) {\n\t    \tsub.init_pending = true;\n\t    \tlet self = this;\n\t    \tPromise.resolve().then(function () {\n\t    \t\tconst eArgs = self.publisher.eventifyInitEventArgs(self.name) || [];\n\t    \t\tfor (let eArg of eArgs) {\n\t    \t\t\tself.trigger(eArg, [sub], true);\n\t    \t\t}\n\t    \t\tsub.init_pending = false;\n\t    \t});\n\t    }\n\t\treturn sub\n\t}\n\n\t/*\n\t\ttrigger event\n\n\t\t- if sub is undefined - publish to all subscriptions\n\t\t- if sub is defined - publish only to given subscription\n\t*/\n\ttrigger (eArg, subs, init) {\n\t\tlet eInfo, ctx;\n\t\tfor (const sub of subs) {\n\t\t\t// ignore terminated subscriptions\n\t\t\tif (sub.terminated) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\teInfo = {\n\t\t\t\tsrc: this.publisher,\n\t\t\t\tname: this.name,\n\t\t\t\tsub: sub,\n\t\t\t\tinit: init\n\t\t\t}\n\t\t\tctx = sub.ctx || this.publisher;\n\t\t\ttry {\n\t\t\t\tsub.callback.call(ctx, eArg, eInfo);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(`Error in ${this.name}: ${sub.callback} ${err}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tunsubscribe from event\n\t- use subscription returned by previous subscribe\n\t*/\n\tunsubscribe(sub) {\n\t\tlet idx = this.subscriptions.indexOf(sub);\n\t\tif (idx > -1) {\n\t\t\tthis.subscriptions.splice(idx, 1);\n\t\t\tsub.terminate();\n\t\t}\n\t}\n}\n\n\n/*\n\tSubscription class\n*/\n\nclass Subscription {\n\n\tconstructor(event, callback, options) {\n\t\toptions = options || {}\n\t\tthis.event = event;\n\t\tthis.name = event.name;\n\t\tthis.callback = callback\n\t\tthis.init = (options.init === undefined) ? this.event.init : options.init;\n\t\tthis.init_pending = false;\n\t\tthis.terminated = false;\n\t\tthis.ctx = options.ctx;\n\t}\n\n\tterminate() {\n\t\tthis.terminated = true;\n\t\tthis.callback = undefined;\n\t\tthis.event.unsubscribe(this);\n\t}\n}\n\n\n/*\n\n\tEVENTIFY INSTANCE\n\n\tEventify brings eventing capabilities to any object.\n\n\tIn particular, eventify supports the initial-event pattern.\n\tOpt-in for initial events per event type.\n\n\teventifyInitEventArgs(name) {\n\t\tif (name == \"change\") {\n\t\t\treturn [this._value];\n\t\t}\n\t}\n\n*/\n\nexport function eventifyInstance (object) {\n\tobject.__eventify_eventMap = new Map();\n\tobject.__eventify_buffer = [];\n\treturn object;\n};\n\n\n/*\n\tEVENTIFY PROTOTYPE\n\n\tAdd eventify functionality to prototype object\n*/\n\nexport function eventifyPrototype(_prototype) {\n\n\tfunction eventifyGetEvent(object, name) {\n\t\tconst event = object.__eventify_eventMap.get(name);\n\t\tif (event == undefined) {\n\t\t\tthrow new Error(\"Event undefined\", name);\n\t\t}\n\t\treturn event;\n\t}\n\n\t/*\n\t\tDEFINE EVENT\n\t\t- used only by event source\n\t\t- name: name of event\n\t\t- options: {init:true} specifies init-event semantics for event\n\t*/\n\tfunction eventifyDefine(name, options) {\n\t\t// check that event does not already exist\n\t\tif (this.__eventify_eventMap.has(name)) {\n\t\t\tthrow new Error(\"Event already defined\", name);\n\t\t}\n\t\tthis.__eventify_eventMap.set(name, new Event(this, name, options));\n\t};\n\n\t/*\n\t\tON\n\t\t- used by subscriber\n\t\tregister callback on event.\n\t*/\n\tfunction on(name, callback, options) {\n\t\treturn eventifyGetEvent(this, name).subscribe(callback, options);\n\t};\n\n\t/*\n\t\tOFF\n\t\t- used by subscriber\n\t\tUn-register a handler from a specfic event type\n\t*/\n\tfunction off(sub) {\n\t\treturn eventifyGetEvent(this, sub.name).unsubscribe(sub);\n\t};\n\n\n\tfunction eventifySubscriptions(name) {\n\t\treturn eventifyGetEvent(this, name).subscriptions;\n\t}\n\n\n\n\t/*\n\t\tTrigger list of eventItems on object\n\n\t\teventItem:  {name:.., eArg:..}\n\n\t\tcopy all eventItems into buffer.\n\t\trequest emptying the buffer, i.e. actually triggering events,\n\t\tevery time the buffer goes from empty to non-empty\n\t*/\n\tfunction eventifyTriggerAll(eventItems) {\n\t\tif (eventItems.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// make trigger items\n\t\t// resolve non-pending subscriptions now\n\t\t// else subscriptions may change from pending to non-pending\n\t\t// between here and actual triggering\n\t\t// make list of [ev, eArg, subs] tuples\n\t\tlet triggerItems = eventItems.map((item) => {\n\t\t\tlet {name, eArg} = item;\n\t\t\tlet ev = eventifyGetEvent(this, name);\n\t\t\tlet subs = ev.subscriptions.filter(sub => sub.init_pending == false);\n\t\t\treturn [ev, eArg, subs];\n\t\t}, this);\n\n\t\t// append trigger Items to buffer\n\t\tconst len = triggerItems.length;\n\t\tconst buf = this.__eventify_buffer;\n\t\tconst buf_len = this.__eventify_buffer.length;\n\t\t// reserve memory - set new length\n\t\tthis.__eventify_buffer.length = buf_len + len;\n\t\t// copy triggerItems to buffer\n\t\tfor (let i=0; i<len; i++) {\n\t\t\tbuf[buf_len+i] = triggerItems[i];\n\t\t}\n\t\t// request emptying of the buffer\n\t\tif (buf_len == 0) {\n\t\t\tlet self = this;\n\t\t\tPromise.resolve().then(function() {\n\t\t\t\tfor (let [ev, eArg, subs] of self.__eventify_buffer) {\n\t\t\t\t\t// actual event triggering\n\t\t\t\t\tev.trigger(eArg, subs, false);\n\t\t\t\t}\n\t\t\t\tself.__eventify_buffer = [];\n\t\t\t});\n\t\t}\n\t}\n\n\t/*\n\t\tTrigger multiple events of same type (name)\n\t*/\n\tfunction eventifyTriggerAlike(name, eArgs) {\n\t\treturn this.eventifyTriggerAll(eArgs.map(eArg => {\n\t\t\treturn {name, eArg};\n\t\t}));\n\t}\n\n\t/*\n\t\tTrigger single event\n\t*/\n\tfunction eventifyTrigger(name, eArg) {\n\t\treturn this.eventifyTriggerAll([{name, eArg}]);\n\t}\n\n\t_prototype.eventifyDefine = eventifyDefine;\n\t_prototype.eventifyTrigger = eventifyTrigger;\n\t_prototype.eventifyTriggerAlike = eventifyTriggerAlike;\n\t_prototype.eventifyTriggerAll = eventifyTriggerAll;\n\t_prototype.eventifySubscriptions = eventifySubscriptions;\n\t_prototype.on = on;\n\t_prototype.off = off;\n};\n\n\n/*\n\tEvent Variable\n\n\tObjects with a single \"change\" event\n*/\n\nexport class EventVariable {\n\n\tconstructor (value) {\n\t\teventifyInstance(this);\n\t\tthis._value = value;\n\t\tthis.eventifyDefine(\"change\", {init:true});\n\t}\n\n\teventifyInitEventArgs(name) {\n\t\tif (name == \"change\") {\n\t\t\treturn [this._value];\n\t\t}\n\t}\n\n\tget value () {return this._value};\n\tset value (value) {\n\t\tif (value != this._value) {\n\t\t\tthis._value = value;\n\t\t\tthis.eventifyTrigger(\"change\", value);\n\t\t}\n\t}\n}\neventifyPrototype(EventVariable.prototype);\n\n/*\n\tEvent Boolean\n\n\n\tNote : implementation uses falsiness of input parameter to constructor and set() operation,\n\tso eventBoolean(-1) will actually set it to true because\n\t(-1) ? true : false -> true !\n*/\n\nexport class EventBoolean extends EventVariable {\n\tconstructor(value) {\n\t\tsuper(Boolean(value));\n\t}\n\n\tset value (value) {\n\t\tsuper.value = Boolean(value);\n\t}\n\tget value () {return super.value};\n}\n\n\n/*\n\tmake a promise which is resolved when EventBoolean changes\n\tvalue.\n*/\nexport function makePromise(eventObject, conditionFunc) {\n\tconditionFunc = conditionFunc || function(val) {return val == true};\n\treturn new Promise (function (resolve, reject) {\n\t\tlet sub = eventObject.on(\"change\", function (value) {\n\t\t\tif (conditionFunc(value)) {\n\t\t\t\tresolve(value);\n\t\t\t\teventObject.off(sub);\n\t\t\t}\n\t\t});\n\t});\n};\n\n// module api\nexport default {\n\teventifyPrototype,\n\teventifyInstance,\n\tEventVariable,\n\tEventBoolean,\n\tmakePromise\n};\n\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n    Wraps the built in setTimeout to provide a\n    Timeout that does not fire too early.\n\n    Importantly, the Timeout object manages at most\n    one timeout.\n\n    - Given clock.now() returns a value in seconds.\n    - The timeout is set with and absolute timestamp,\n      not a delay.\n*/\n\nclass Timeout {\n\n    constructor (timingObject, callback) {\n        this.tid = undefined;\n        this.to = timingObject;\n        this.callback = callback;\n    }\n\n    isSet() {\n        return this.tid != undefined;\n    }\n\n    /*\n        set timeout to point in time (seconds)\n    */\n    setTimeout(target_ts, arg) {\n        if (this.tid != undefined) {\n            throw new Error(\"at most on timeout\");\n        }\n        let now = this.to.clock.now();\n        let delay = Math.max(target_ts - now, 0) * 1000;\n        this.tid = setTimeout(this.onTimeout.bind(this), delay, target_ts, arg);\n    }\n\n    /*\n        handle timeout intended for point in time (seconds)\n    */\n    onTimeout(target_ts, arg) {\n        if (this.tid != undefined) {\n            this.tid = undefined;\n            // check if timeout was too early\n            let now = this.to.clock.now()\n            if (now < target_ts) {\n                // schedule new timeout\n                this.setTimeout(target_ts, arg);\n            } else {\n                // handle timeout\n                this.callback(now, arg);\n            }\n        }\n    }\n\n    /*\n        cancel and clear timeout if active\n    */\n    clear() {\n        if (this.tid != undefined) {\n            clearTimeout(this.tid);\n            this.tid = undefined;\n        }\n    }\n}\n\nexport default Timeout;\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mæhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n\tMASTER CLOCK\n\n\n\tMasterClock is the reference clock used by TimingObjects.\n\n\tIt is implemented using performance.now,\n\tbut is skewed and rate-adjusted relative to this local clock.\n\n\tThis allows it to be used as a master clock in a distributed system,\n\twhere synchronization is generally relative to some other clock than the local clock.\n\n\tThe master clock may need to be adjusted in time, for instance as a response to\n\tvarying estimation of clock skew or drift. The master clock supports an adjust primitive for this purpose.\n\n\tWhat policy is used for adjusting the master clock may depend on the circumstances\n\tand is out of scope for the implementation of the MasterClock.\n\tThis policy is implemented by the timing object. This policy may or may not\n\tprovide monotonicity.\n\n\tA change event is emitted every time the masterclock is adjusted.\n\n\tVector values define\n\t- position : absolute value of the clock in seconds\n\t- velocity : how many seconds added per second (1.0 exactly - or very close)\n\t- timestamp : timstamp from local system clock (performance) in seconds. Defines point in time where position and velocity are valid.\n\n\tIf initial vector is not provided, default value is\n\t{position: now, velocity: 1.0, timestamp: now};\n\timplying that master clock is equal to local clock.\n*/\n\nimport eventify from '../util/eventify.js';\n\n\n// Need a polyfill for performance,now as Safari on ios doesn't have it...\n(function(){\n    if (\"performance\" in window === false) {\n        window.performance = {};\n        window.performance.offset = new Date().getTime();\n    }\n    if (\"now\" in window.performance === false){\n      window.performance.now = function now(){\n        return new Date().getTime() - window.performance.offset;\n      };\n    }\n\t})();\n\n// local clock in seconds\nconst local_clock = {\n\tnow : function () {return performance.now()/1000.0;}\n};\n\nfunction calculateVector(vector, tsSec) {\n\tif (tsSec === undefined) tsSec = local_clock.now();\n\tvar deltaSec = tsSec - vector.timestamp;\n\treturn {\n\t\tposition : vector.position + vector.velocity*deltaSec,\n\t\tvelocity : vector.velocity,\n\t\ttimestamp : tsSec\n\t};\n};\n\nclass MasterClock {\n\n\tconstructor (options) {\n\t\tvar now = local_clock.now();\n\t\toptions = options || {};\n\t\tthis._vector  = {position: now, velocity: 1.0, timestamp: now};\n\t\t// event support\n\t\teventify.eventifyInstance(this);\n\t\tthis.eventifyDefine(\"change\", {init:false}); // define change event (no init-event)\n\t\t// adjust\n\t\tthis.adjust(options);\n\t};\n\n\t/*\n\t\tADJUST\n\t\t- could also accept timestamp for velocity if needed?\n\t\t- given skew is relative to local clock\n\t\t- given rate is relative to local clock\n\t*/\n\tadjust(options) {\n\t\toptions = options || {};\n\t\tvar now = local_clock.now();\n\t\tvar nowVector = this.query(now);\n\t\tif (options.skew === undefined && options.rate === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tthis._vector = {\n\t\t\tposition : (options.skew !== undefined) ? now + options.skew : nowVector.position,\n\t\t\tvelocity : (options.rate !== undefined) ? options.rate : nowVector.velocity,\n\t\t\ttimestamp : nowVector.timestamp\n\t\t}\n\t\tthis.eventifyTrigger(\"change\");\n\t};\n\n\t/*\n\t\tNOW\n\t\t- calculates the value of the clock right now\n\t\t- shorthand for query\n\t*/\n\tnow() {\n\t\treturn calculateVector(this._vector, local_clock.now()).position;\n\t};\n\n\t/*\n\t\tQUERY\n\t\t- calculates the state of the clock right now\n\t\t- result vector includes position and velocity\n\t*/\n\tquery(now) {\n\t\treturn calculateVector(this._vector, now);\n\t};\n\n}\neventify.eventifyPrototype(MasterClock.prototype);\n\nexport default MasterClock;\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mæhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nimport MasterClock from './masterclock.js';\nimport {calculateVector, checkRange} from '../util/motionutils.js';\n\n\n/*\n\tINTERNAL PROVIDER\n\n\tTiming provider internal to the browser context\n\n\tUsed by timing objects as timingsrc if no timingsrc is specified.\n*/\n\nclass InternalProvider {\n\n\tconstructor (callback, options) {\n\t\toptions = options || {};\n\t\t// initialise internal state\n\t\tthis._clock = new MasterClock({skew:0});\n\t\tthis._range = [-Infinity, Infinity];\n\t\tthis._vector;\n\t\tthis._callback = callback;\n\t\t// options\n\t\toptions.timestamp = options.timestamp || this._clock.now();\n\t\tthis._process_update(options);\n\t};\n\n\t// internal clock\n\tget clock() {return this._clock;};\n\tget range() {return this._range;};\n\tget vector() {return this._vector;};\n\n\tisReady() {return true;};\n\n\t// update\n\t_process_update(arg) {\n\t\t// process arg\n\t\tlet {\n\t\t\tposition: pos,\n\t\t\tvelocity: vel,\n\t\t\tacceleration: acc,\n\t\t\ttimestamp: ts,\n\t\t\trange: range,\n\t\t\t...rest\n\t\t} = arg;\n\n\t\t// record state from current motion\n\t\tlet p = 0, v = 0, a = 0;\n\t\tif (this._vector != undefined) {\n\t\t\tlet nowVector = calculateVector(this._vector, ts);\n\t\t\tnowVector = checkRange(nowVector, this._range);\n\t\t\tp = nowVector.position;\n\t\t\tv = nowVector.velocity;\n\t\t\ta = nowVector.acceleration;\n\t\t}\n\n\t\t// fill in from current motion, for missing properties\n\t\tlet vector = {\n\t\t\tposition : (pos != undefined) ? pos : p,\n\t\t\tvelocity : (vel != undefined) ? vel : v,\n\t\t\tacceleration : (acc != undefined) ? acc : a,\n\t\t\ttimestamp : ts\n\t\t};\n\n\t\t// update range\n\t\tif (range != undefined) {\n\t\t\tlet [low, high] = range;\n\t\t\tif (low < high) {\n\t\t\t\tif (low != this._range[0] || high != this._range[1]) {\n\t\t\t\t\tthis._range = [low, high];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// check vector with respect to range\n\t\tvector = checkRange(vector, this._range);\n\t\t// save old vector\n\t\tthis._old_vector = this._vector;\n\t\t// update vector\n\t\tthis._vector = vector;\n\t\treturn {range, ...vector, ...rest};\n\t};\n\n\t// update\n\tupdate(arg) {\n\t\targ = this._process_update(arg);\n\t\treturn this._callback(arg);\n\t}\n\n\tclose() {\n\t\tthis._callback = undefined;\n\t}\n}\n\nexport default InternalProvider;\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mæhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n\n\nimport MasterClock from './masterclock.js';\n\n\nfunction checkTimingProvider(obj){\n\tlet required = [\"on\", \"skew\", \"vector\", \"range\", \"update\"];\n\tfor (let prop of required) {\n\t\tif (!(prop in obj)) {\n\t\t\tthrow new Error(`TimingProvider ${obj} missing property ${prop}`);\n\t\t}\n\t}\n}\n\n\n/*\n\tEXTERNAL PROVIDER\n\n\tExternal Provider bridges the gap between the PROVIDER API (implemented by external timing providers)\n\tand the TIMINGSRC API\n\n\tObjects implementing the TIMINGSRC API may be used as timingsrc (parent) for another timing object.\n\n\t- wraps a timing provider external\n\t- handles some complexity that arises due to the very simple API of providers\n\t- implements a clock for the provider\n*/\n\nclass ExternalProvider {\n\n\tconstructor(provider, callback, options) {\n\t\tcheckTimingProvider(provider);\n\t\toptions = options || {};\n\n\t\tthis._provider = provider;\n\t\tthis._callback = callback;\n\t\tthis._range;\n\t\tthis._vector;\n\t\tthis._ready = false\n\n\t\t/*\n\t\t\tprovider clock (may fluctuate based on live skew estimates)\n\t\t*/\n\t\tthis._provider_clock;\n\t\t/*\n\t\t\tlocal clock\n\t\t\tprovider clock normalised to values of performance now\n\t\t\tnormalisation based on first skew measurement, so\n\t\t*/\n\t\tthis._clock;\n\n\n\t\t// register event handlers\n\t\tthis._provider.on(\"vectorchange\", this._onVectorChange.bind(this));\n\t\tthis._provider.on(\"skewchange\", this._onSkewChange.bind(this));\n\n\t\t// check if provider is ready\n\t\tlet self = this;\n\t\tif (this._provider.skew != undefined) {\n\t\t\tlet self = this;\n\t\t\tPromise.resolve(function () {\n\t\t\t\tself._onSkewChange();\n\t\t\t});\n\t\t}\n\t};\n\n\tisReady() {return this._ready;};\n\n\t// internal clock\n\tget clock() {return this._clock;};\n\tget range() {return this._range;};\n\n\n\t/*\n\t\t- local timestamp of vector is set for each new vector, using the skew available at that time\n\t\t- the vector then remains unchanged\n\t\t- skew changes affect local clock, thereby affecting the result of query operations\n\n\t\t- one could imagine reevaluating the vector as well when the skew changes,\n\t\t\tbut then this should be done without triggering change events\n\n\t\t- ideally the vector timestamp should be a function of the provider clock\n\t*/\n\n\tget vector() {\n\t\t// local_ts = provider_ts - skew\n\t\tlet local_ts = this._vector.timestamp - this._provider.skew;\n\t\treturn {\n\t\t\tposition : this._vector.position,\n\t\t\tvelocity : this._vector.velocity,\n\t\t\tacceleration : this._vector.acceleration,\n\t\t\ttimestamp : local_ts\n\t\t}\n\t}\n\n\n\t// internal provider object\n\tget provider() {return this._provider;};\n\n\n\t_onSkewChange() {\n\t\tif (!this._clock) {\n\t\t\tthis._provider_clock = new MasterClock({skew: this._provider.skew});\n\t\t\tthis._clock = new MasterClock({skew:0});\n\t\t} else {\n\t\t\tthis._provider_clock.adjust({skew: this._provider.skew});\n\t\t\t// provider clock adjusted with new skew - correct local clock similarly\n\t\t\t// current_skew = clock_provider - clock_local\n\t\t\tlet current_skew = this._provider_clock.now() - this._clock.now();\n\t\t\t// skew delta = new_skew - current_skew\n\t\t\tlet skew_delta = this._provider.skew - current_skew;\n\t\t\tthis._clock.adjust({skew: skew_delta});\n\t\t}\n\t\tif (!this.isReady() && this._provider.vector != undefined) {\n\t\t\t// just became ready\n\t\t\tthis._ready = true;\n\t\t\tthis._range = this._provider.range;\n\t\t\tthis._vector = this._provider.vector;\n\t\t\tlet eArg = {\n\t\t\t\trange: this.range,\n\t\t\t\t...this.vector,\n\t\t\t\tlive: false\n\t\t\t}\n\t\t\tthis._callback(eArg);\n\t\t}\n\t};\n\n\t_onVectorChange() {\n\t\tif (this._clock) {\n\t\t\t// is ready (onSkewChange has fired earlier)\n\t\t\tif (!this._ready) {\n\t\t\t\tthis._ready = true;\n\t\t\t}\n\t\t\tif (!this._range) {\n\t\t\t\tthis._range = this._provider.range;\n\t\t\t}\n\t\t\tthis._vector = this._provider.vector;\n\t\t\tlet eArg = {\n\t\t\t\trange: this.range,\n\t\t\t\t...this.vector\n\t\t\t}\n\t\t\tthis._callback(eArg);\n\t\t}\n\t};\n\n\n\t// update\n\t/*\n\t\tTODO - support setting range on provider\n\t\tTODO - suppport tunnel\n\t\tTODO - support onRangeChange from provider\n\t*/\n\tupdate(arg) {\n\t\tlet vector = {\n\t\t\tposition: arg.position,\n\t\t\tvelocity: arg.velocity,\n\t\t\tacceleration: arg.acceleration,\n\t\t\ttimestamp: arg.timestamp\n\t\t};\n\t\t// calc back to provider ts\n\t\t// local_ts = provider_ts - skew\n\t\tvector.timestamp = vector.timestamp + this._provider.skew;\n\t\tlet res = this._provider.update(vector);\n\t\t// return success\n\t\treturn true;\n\t};\n}\n\nexport default ExternalProvider;\n\n\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Mæhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nimport eventify from '../util/eventify.js';\nimport Timeout from '../util/timeout.js';\nimport * as motionutils from '../util/motionutils.js';\nimport InternalProvider from './internalprovider.js';\nimport ExternalProvider from './externalprovider.js';\n\nconst MAX_NONCE = 10000;\n\nfunction getRandomInt() {\n \treturn Math.floor(Math.random() * MAX_NONCE);\n};\n\nfunction isTimingProvider(obj){\n\tlet required = [\"on\", \"skew\", \"vector\", \"range\", \"update\"];\n\tfor (let prop of required) {\n\t\tif (!(prop in obj)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction checkRange(live, now, vector, range) {\n\tif (live) {\n\t\treturn motionutils.checkRange(vector, range);\n\t} else {\n\t\tlet now_vector = motionutils.calculateVector(vector, now);\n\t\treturn motionutils.checkRange(now_vector, range);\n\t}\n}\n\n\n\n/*\n\tTIMING BASE\n\n\tabstract base class for objects that may be used as timingsrc\n\n\tessential internal state\n\t- range, vector\n\n\texternal methods\n\tquery, update\n\n\tevents\n\ton/off \"change\", \"timeupdate\"\n\n\tinternal methods for range timeouts\n\n\tdefines internal processing steps\n\t- handleEvent(arg) <- from external timingobject\n\t\t- vector = onChange(vector)\n\t\t- process(vector) <- from timeout or preProcess\n\t- handleTimeout(arg) <- timeout on range restrictions\n\t- process (arg)\n\t\t- set internal vector, range\n\t\t- dispatchEvents(arg)\n\t\t- renew range timeout\n\t- dispatchEvent (arg)\n\t\t- emit change event and timeupdate event\n\t\t- turn periodic timeupdate on or off\n\n\tindividual steps in this structure may be specialized\n\tby subclasses (i.e. timing converters)\n*/\n\n\nclass TimingObject {\n\n\tconstructor (timingsrc, options) {\n\n\t\t// special support for options given as first and only argument\n\t\t// equivalent to new TimingObject(undefined, options)\n\t\t// in this case, timingsrc may be found in options\n\t\tif (timingsrc != undefined && options == undefined) {\n\t\t\tif (!(timingsrc instanceof TimingObject) && !isTimingProvider(timingsrc)) {\n\t\t\t\t// timingsrc is neither timing object nor timingprovider\n\t\t\t\t// assume timingsrc is options\n\t\t\t\toptions = timingsrc;\n\t\t\t\ttimingsrc = undefined;\n\t\t\t\tif (options.provider) {\n\t\t\t\t\ttimingsrc = options.provider;\n\t\t\t\t} else if (options.timingsrc) {\n\t\t\t\t\ttimingsrc = options.timingsrc;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// options\n\t\toptions = options || {};\n\t\tthis.__options = options;\n\n\n\t\t// default timeout option\n\t\tif (options.timeout == undefined) {\n\t\t\toptions.timeout = true;\n\t\t}\n\n\t\t// cached vectors and range\n\t\tthis.__old_vector;\n\t\tthis.__vector;\n\t\tthis.__range = [-Infinity, Infinity];\n\n\t\t// range restriction timeout\n\t\tthis.__timeout = new Timeout(this, this.__handleTimeout.bind(this));\n\n\t\t// timeoutid for timeupdate event\n\t\tthis.__tid = undefined;\n\n\t\t// timingsrc\n\t\tthis.__timingsrc;\n\t\tthis.__sub;\n\n\t\t// update promises\n\t\tthis.__update_events = new Map();\n\n\t\t// readiness\n\t\tthis.__ready = new eventify.EventBoolean();\n\n\t\t// exported events\n\t\teventify.eventifyInstance(this);\n\t\tthis.eventifyDefine(\"timingsrc\", {init:true});\n\t\tthis.eventifyDefine(\"change\", {init:true});\n\t\tthis.eventifyDefine(\"rangechange\", {init:true});\n\t\tthis.eventifyDefine(\"timeupdate\", {init:true});\n\n\t\t// initialise timingsrc\n\t\tthis.__set_timingsrc(timingsrc, options);\n\t};\n\n\n\t/***************************************************************\n\n\t\tEVENTS\n\n\t***************************************************************/\n\n\t/*\n\t  \toverrides how immediate events are constructed\n\t  \tspecific to eventutils\n\t  \t- overrides to add support for timeupdate events\n\t*/\n\teventifyInitEventArgs(name) {\n\t\tif (this.__ready.value) {\n\t\t\tif (name == \"timingsrc\") {\n\t\t\t\tlet eArg = {\n\t\t\t\t\t...this.__vector,\n\t\t\t\t\trange: this.__range,\n\t\t\t\t\tlive:false\n\t\t\t\t}\n\t\t\t\treturn [eArg];\n\t\t\t} else if (name == \"timeupdate\") {\n\t\t\t\treturn [undefined];\n\t\t\t} else if (name == \"change\") {\n\t\t\t\treturn [this.__vector];\n\t\t\t} else if (name == \"rangechange\") {\n\t\t\t\treturn [this.__range];\n\t\t\t}\n\t\t}\n\t};\n\n\n\t/***************************************************************\n\n\t\tACCESSORS\n\n\t***************************************************************/\n\n\t// ready or not\n\tisReady() {return this.__ready.value;};\n\n\t// ready promise\n    get ready() {return eventify.makePromise(this.__ready);};\n\n    // range\n    get range() {\n    \t// copy\n    \treturn [this.__range[0], this.__range[1]];\n    };\n\n    // vector\n    get vector() {\n    \t// copy\n\t\treturn {\n\t\t\tposition : this.__vector.position,\n\t\t\tvelocity : this.__vector.velocity,\n\t\t\tacceleration : this.__vector.acceleration,\n\t\t\ttimestamp : this.__vector.timestamp\n\t\t};\n    };\n\n    // old vector\n    get old_vector() {return this.__old_vector;};\n\n    // delta\n    get delta() {\n    \treturn new motionutils.MotionDelta(this.__old_vector, this.__vector);\n    }\n\n\t// clock - from timingsrc or provider\n\tget clock() {return this.__timingsrc.clock};\n\n\n\n\t/***************************************************************\n\n\t\tQUERY\n\n\t***************************************************************/\n\n\t// query\n\tquery() {\n\t\tif (this.__ready.value == false)  {\n\t\t\tthrow new Error(\"query before timing object is ready\");\n\t\t}\n\t\t// reevaluate state to handle range violation\n\t\tlet vector = motionutils.calculateVector(this.__vector, this.clock.now());\n\t\t// detect range violation - only if timeout is set {\n\t\tif (this.__timeout.isSet()) {\n\t\t\tif (vector.position < this.__range[0] || this.__range[1] < vector.position) {\n\t\t\t\t// emulate update event to trigger range restriction\n\t\t\t\tthis.__process({...this.onRangeViolation(vector)});\n\t\t\t}\n\t\t\t// re-evaluate query after state transition\n\t\t\treturn motionutils.calculateVector(this.__vector, this.clock.now());\n\t\t}\n\t\treturn vector;\n\t};\n\n\t// shorthand query\n\tget pos() {return this.query().position;};\n\tget vel() {return this.query().velocity;};\n\tget acc() {return this.query().acceleration;};\n\n\n\t/***************************************************************\n\n\t\tUPDATE\n\n\t***************************************************************/\n\n\t// internal update\n\t__update(arg) {\n\t\tif (this.__timingsrc instanceof TimingObject) {\n\t\t\treturn this.__timingsrc.__update(arg);\n\t\t} else {\n\t\t\t// provider\n\t\t\treturn this.__timingsrc.update(arg);\n\t\t}\n\t};\n\n\t// external update\n\tupdate(arg) {\n\t\t// check if noop\n\t\tlet ok = (arg.range != undefined);\n\t\tok = ok || (arg.position != undefined);\n\t\tok = ok || (arg.velocity != undefined);\n\t\tok = ok || (arg.acceleration != undefined);\n\t\tif (!ok) {\n\t\t\treturn Promise.resolve(arg);\n\t\t}\n\t\targ.tunnel = getRandomInt();\n\t\tif (arg.timestamp == undefined) {\n\t\t\targ.timestamp = this.clock.now();\n\t\t}\n\t\tlet event = new eventify.EventVariable();\n\t\tthis.__update_events.set(arg.tunnel, event);\n\t\tlet promise = eventify.makePromise(event, val => (val != undefined));\n\t\tthis.__update(arg);\n\t\treturn promise;\n\t}\n\n\n\t/***************************************************************\n\n\t\tCORE UPDATE PROCESSING\n\n\t***************************************************************/\n\n\t/*\n\t\tdo not override\n\t\thandle incoming change event\n\t\teArg = {vector:vector, range:range, live:true}\n\n\t\tsubclasses may specialise behaviour by overriding\n\t\tonVectorChange\n\n\t*/\n\t__handleEvent(arg) {\n\t\tlet {\n\t\t\trange,\n\t\t\tlive = true,\n\t\t\t...rest\n\t\t} = arg;\n\t\t// copy range object\n\t\tif (range != undefined) {\n\t\t\trange = [range[0], range[1]];\n\t\t}\n\t\t// new arg object\n\t\tlet _arg = {\n\t\t\trange,\n\t\t\tlive,\n\t\t\t...rest,\n\t\t};\n\t\t_arg = this.onUpdateStart(_arg);\n\t\tif (_arg != undefined) {\n\t\t\treturn this.__process(_arg);\n\t\t}\n\t};\n\n\t/*\n\t\tdo not override\n\t\thandle timeout\n\t*/\n\t__handleTimeout(now, vector) {\n\t\tthis.__process({...this.onRangeViolation(vector)});\n\t}\n\n\t/*\n\t\tcore processing step after change event or timeout\n\t\tassignes the internal vector\n\t*/\n\t__process(arg) {\n\t\tlet {\n\t\t\trange,\n\t\t\tposition,\n\t\t\tvelocity,\n\t\t\tacceleration,\n\t\t\ttimestamp,\n\t\t\tlive=true,\n\t\t\t...rest\n\t\t} = arg;\n\n\n\t\t// update range\n\t\tlet range_change = false;\n\t\tif (range != undefined) {\n\t\t\tlet [low, high] = range;\n\t\t\tif (low < high) {\n\t\t\t\tif (low != this.__range[0] || high != this.__range[1]) {\n\t\t\t\t\tthis.__range = [low, high];\n\t\t\t\t\trange = [low, high];\n\t\t\t\t\trange_change = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update vector\n\t\tlet vector;\n\t\tlet vector_change = false;\n\t\tlet now = this.clock.now();\n\n\t\t// make sure vector is consistent with range\n\t\tif (position != undefined) {\n\t\t\t// vector change\n\t\t\tvector = {position, velocity, acceleration, timestamp};\n\t\t\t// make sure vector is consistent with range\n\t\t\tvector = checkRange(live, now, vector, this.__range);\n\t\t} else {\n\t\t\t// there is no vector change, but if range was changed,\n\t\t\t// the current vector must be checked for new range.\n\t\t\tif (range_change) {\n\t\t\t\tvector = checkRange(false, now, this.__vector, this.__range);\n\t\t\t}\n\t\t}\n\n\t\tif (vector != undefined) {\n\t\t\t// update vector\n\t\t\tif (this.__vector != undefined) {\n\t\t\t\tvector_change = !motionutils.equalVectors(vector, this.__vector);\n\t\t\t} else {\n\t\t\t\tvector_change = true;\n\t\t\t}\n\t\t\tif (vector_change) {\n\t\t\t\t// save old vector\n\t\t\t\tthis.__old_vector = this.__vector;\n\t\t\t\t// update vector\n\t\t\t\tthis.__vector = vector;\n\t\t\t}\n\t\t}\n\n\t\tlet _arg;\n\t\tif (range_change && vector_change) {\n\t\t\t_arg = {range, ...vector, live, ...rest};\n\t\t} else if (range_change) {\n\t\t\t_arg = {range, live, ...rest};\n\t\t} else if (vector_change) {\n\t\t\t_arg = {...vector, live, ...rest};\n\t\t} else {\n\t\t\t_arg = {live, ...rest};\n\t\t}\n\n\t\t// trigger events\n\t\tthis.__ready.value = true;\n\t\tthis.__dispatchEvents(_arg, range_change, vector_change);\n\t\t// renew timeout\n\t\tif (this.__options.timeout) {\n\t\t\tthis.__renewTimeout();\n\t\t}\n\t\t// release update promises\n\t\tif (_arg.tunnel != undefined) {\n\t\t\tlet event = this.__update_events.get(_arg.tunnel);\n\t\t\tif (event) {\n\t\t\t\tthis.__update_events.delete(_arg.tunnel);\n\t\t\t\tdelete _arg.tunnel;\n\t\t\t\tevent.value = _arg;\n\t\t\t}\n\t\t}\n\t\t// TODO\n\t\t// since externalprovider does not support tunnel yet\n\t\t// free all remaining promises\n\t\tfor (let event of this.__update_events.values()) {\n\t\t\tevent.value = {};\n\t\t}\n\t\tthis.onUpdateDone(_arg);\n\t\treturn _arg;\n\t};\n\n\t/*\n\t\tprocess a new vector applied in order to trigger events\n\t\toverriding this is only necessary if external change events\n\t\tneed to be suppressed,\n\t*/\n\t__dispatchEvents(arg, range_change, vector_change) {\n\t\tlet {\n\t\t\trange,\n\t\t\tposition,\n\t\t\tvelocity,\n\t\t\tacceleration,\n\t\t\ttimestamp\n\t\t} = arg;\n\t\t// trigger timingsrc events\n\t\tthis.eventifyTrigger(\"timingsrc\", arg);\n\t\t// trigger public change events\n\t\tif (vector_change) {\n\t\t\tlet vector = {position, velocity, acceleration, timestamp};\n\t\t\tthis.eventifyTrigger(\"change\", vector);\n\t\t}\n\t\tif (range_change) {\n\t\t\tthis.eventifyTrigger(\"rangechange\", range);\n\t\t}\n\t\t// trigger timeupdate events\n\t\tthis.eventifyTrigger(\"timeupdate\");\n\t\tlet moving = motionutils.isMoving(this.__vector);\n\t\tif (moving && this.__tid === undefined) {\n\t\t\tlet self = this;\n\t\t\tthis.__tid = setInterval(function () {\n\t\t\t\tself.eventifyTrigger(\"timeupdate\");\n\t\t\t}, 200);\n\t\t} else if (!moving && this.__tid !== undefined) {\n\t\t\tclearTimeout(this.__tid);\n\t\t\tthis.__tid = undefined;\n\t\t}\n\t};\n\n\n\t/***************************************************************\n\n\t\tSUBCLASS MAY OVERRIDE\n\n\t***************************************************************/\n\n\t/*\n\t\tmay be overridden\n\t*/\n\tonRangeViolation(vector) {return vector;};\n\n\t/*\n\t\tmay be overridden\n\t*/\n\tonUpdateStart(arg) {return arg;};\n\n\t/*\n\t\tmay be overridden\n\t*/\n\tonUpdateDone(arg) {};\n\n\n\t/***************************************************************\n\n\t\tTIMEOUTS\n\n\t***************************************************************/\n\n\t/*\n\t\trenew timeout is called during every processing step\n\t\tin order to recalculate timeouts.\n\n\t\t- optional vector - default is own vector\n\t\t- optional range - default is own range\n\t*/\n\t__renewTimeout(vector, range) {\n\t\tthis.__timeout.clear();\n\t\tlet timeout_vector = this.__calculateTimeoutVector(vector, range);\n\t\tif (timeout_vector == undefined) {\n\t\t\treturn;\n\t\t}\n\t\tthis.__timeout.setTimeout(timeout_vector.timestamp, timeout_vector);\n\t};\n\n\n\t/*\n\t\tcalculate a vector that will be delivered to _process().\n\t\tthe timestamp in the vector determines when it is delivered.\n\n\t\t- optional vector - default is own vector\n\t\t- optional range - default is own range\n\t*/\n\t__calculateTimeoutVector(vector, range) {\n\t\tvector = vector || this.__vector;\n\t\trange = range || this.__range;\n\t\tlet now = this.clock.now();\n\t\tlet now_vector = motionutils.calculateVector(vector, now);\n\t\tlet [delta, pos] = motionutils.calculateDelta(now_vector, range);\n\t\tif (delta == undefined || delta == Infinity) {\n\t\t\treturn;\n\t\t}\n\t\t// vector when range restriction will be reached\n\t\tlet timeout_vector = motionutils.calculateVector(vector, now + delta);\n\t\t// possibly avoid rounding errors\n\t\ttimeout_vector.position = pos;\n\t\treturn timeout_vector;\n\t};\n\n\n\t/***************************************************************\n\n\t\tTIMINGSRC\n\n\t***************************************************************/\n\n\t/*\n\n\t\ttimingsrc property and switching on assignment\n\n\t*/\n\t__clear_timingsrc() {\n\t\t// clear timingsrc\n\t\tif (this.__timingsrc != undefined) {\n\t\t\tif (this.__timingsrc instanceof TimingObject) {\n\t\t\t\tthis.__timingsrc.off(this.__sub);\n\t\t\t\tthis.__sub = undefined;\n\t\t\t\tthis.__timingsrc = undefined;\n\t\t\t} else {\n\t\t\t\t// provider\n\t\t\t\tthis.__timingsrc.close();\n\t\t\t\tthis.__timingsrc = undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\t__set_timingsrc(timingsrc, options) {\n\t\t// set timingsrc\n\t\tlet callback = this.__handleEvent.bind(this);\n\t\tif (timingsrc instanceof TimingObject) {\n\t\t\t// timingsrc\n\t\t\tthis.__timingsrc = timingsrc;\n\t\t\tthis.__sub = this.__timingsrc.on(\"timingsrc\", callback);\n\t\t} else {\n\t\t\t// provider\n\t\t\tif (timingsrc == undefined) {\n\t\t\t\t// Internal Provider\n\t\t\t\tthis.__timingsrc = new InternalProvider(callback, options);\n\t\t\t} else {\n\t\t\t\t// External Provider\n\t\t\t\tthis.__timingsrc = new ExternalProvider(timingsrc, callback, options);\n\t\t\t}\n\t\t\t// emulating initial event from provider, causing\n\t\t\t// this timingobject to initialise\n\t\t\tif (this.__timingsrc.isReady()) {\n\t\t\t\tlet arg = {\n\t\t\t\t\trange: this.__timingsrc.range,\n\t\t\t\t\t...this.__timingsrc.vector,\n\t\t\t\t\tlive: false\n\t\t\t\t}\n\t\t\t\t// generate initial event\n\t\t\t\tcallback(arg);\n\t\t\t}\n\t\t}\n\t}\n\n\tget timingsrc () {return this.__timingsrc;};\n\tset timingsrc(timingsrc) {\n\t\tthis.__clear_timingsrc();\n\t\tthis.__set_timingsrc(timingsrc);\n\t}\n\n}\n\neventify.eventifyPrototype(TimingObject.prototype);\n\nexport default TimingObject;\n\n\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mæhlum Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n\tSKEW CONVERTER\n\n\tSkewing the timeline by 2 means that the timeline position 0 of the timingsrc becomes position 2 of Converter.\n\n*/\n\n\nimport TimingObject from './timingobject.js';\n\n\nclass SkewConverter extends TimingObject {\n\n\tconstructor (timingsrc, skew, options) {\n\t\tsuper(timingsrc, options);\n\t\tthis._skew = skew;\n        this.eventifyDefine(\"skewchange\", {init:true});\n\t}\n\n    // extend\n    eventifyInitEventArgs(name) {\n        if (name == \"skewchange\") {\n            return [this._skew];\n        } else {\n            return super.eventifyInitEventArgs(name)\n        }\n    }\n\n\t// overrides\n\tonUpdateStart(arg) {\n        if (arg.range != undefined) {\n            arg.range[0] += this._skew;\n            arg.range[1] += this._skew;\n        }\n        if (arg.position != undefined) {\n\t\t\targ.position += this._skew;\n        }\n        return arg;\n\t};\n\n\t// overrides\n\tupdate(arg) {\n        if (arg.position != undefined) {\n\t\t\targ.position -= this._skew;\n        }\n        if (arg.range != undefined) {\n            let [low, high] = arg.range;\n            arg.range = [low - this._skew, high - this._skew];\n        }\n\t\treturn super.update(arg);\n\t};\n\n\tget skew() {return this._skew;};\n\n\tset skew(skew) {\n        if (skew != this._skew) {\n            // set skew and emulate new event from timingsrc\n\t\t\tthis._skew = skew;\n\t\t\tthis.__handleEvent({\n                ...this.timingsrc.vector,\n                range: this.timingsrc.range\n            });\n            this.eventifyTrigger(\"skewchange\", skew);\n        }\n\t}\n};\n\nexport default SkewConverter;\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mæhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n\tDELAY CONVERTER\n\n\tDelay Converter introduces a positive time delay on a source timing object.\n\n\tGenerally - if the source timing object has some value at time t,\n\tthen the delayConverter will provide the same value at time t + delay.\n\n\tSince the delay Converter is effectively replaying past events after the fact,\n\tit is not LIVE and not open to interactivity (i.e. update)\n\n*/\n\nimport TimingObject from './timingobject.js';\nimport Timeout from '../util/timeout.js';\n\n\nclass DelayConverter extends TimingObject {\n\tconstructor (timingObject, delay) {\n\t\tif (delay < 0) {throw new Error (\"negative delay not supported\");}\n\t\tif (delay === 0) {throw new Error (\"zero delay makes delayconverter pointless\");}\n\t\tsuper(timingObject);\n\t\t// fixed delay\n\t\tthis._delay = delay;\n\t\t// buffer\n\t\tthis._buffer = [];\n\t\t// timeoutid\n\t\tthis._timeout = new Timeout(this, this.__handleDelayed.bind(this));\n        this.eventifyDefine(\"delaychange\", {init:true});\n\t};\n\n    // extend\n    eventifyInitEventArgs(name) {\n        if (name == \"delaychange\") {\n            return [this._delay];\n        } else {\n            return super.eventifyInitEventArgs(name)\n        }\n    }\n\n\t// overrides\n\tonUpdateStart(arg) {\n\t\t/*\n\t\t\tVector's timestamp always time-shifted (back-dated) by delay\n\n\t\t\tNormal operation is to delay every incoming vector update.\n\t\t\tThis implies returning null to abort further processing at this time,\n\t\t\tand instead trigger a later continuation.\n\n\t\t\tHowever, delay is calculated based on the timestamp of the vector (age), not when the vector is\n\t\t\tprocessed in this method. So, for small small delays the age of the vector could already be\n\t\t\tgreater than delay, indicating that the vector is immediately valid and do not require delayed processing.\n\n\t\t\tThis is particularly true for the first vector, which may be old.\n\n\t\t\tSo we generally check the age to figure out whether to apply the vector immediately or to delay it.\n\t\t*/\n\n\t\tthis._buffer.push(arg);\n\t\t// if timeout for next already defined, nothing to do\n\t\tif (!this._timeout.isSet()) {\n\t\t\tthis.__handleDelayed();\n\t\t}\n\t\treturn;\n\t};\n\n\t__handleDelayed() {\n\t\t// run through buffer and apply vectors that are due\n\t\tlet now = this.clock.now();\n\t\tlet arg, due;\n\t\twhile (this._buffer.length > 0) {\n\t\t\tdue = this._buffer[0].timestamp + this._delay;\n\t\t\tif (now < due) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\targ = this._buffer.shift();\n\t\t\t\t// apply\n\t\t\t\targ.timestamp = due;\n\t\t\t\tthis.__process(arg);\n\t\t\t}\n\t\t}\n\t\t// set new timeout\n\t\tif (this._buffer.length > 0) {\n\t\t\tdue = this._buffer[0].timestamp + this._delay;\n\t\t\tthis._timeout.setTimeout(due);\n\t\t}\n\t};\n\n\tupdate(arg) {\n\t\t// Updates are prohibited on delayed timingobjects\n\t\tthrow new Error (\"update is not legal on delayed (non-live) timingobject\");\n\t};\n\n    get delay() {return this._delay;};\n\n\tset delay(delay) {\n        if (delay != this._delay) {\n            // set delay and emulate new event from timingsrc\n            this._delay = delay;\n            this._timeout.clear();\n            this.__handleDelayed();\n            this.eventifyTrigger(\"delaychange\", delay);\n        }\n    }\n}\n\nexport default DelayConverter;\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mæhlum Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tSCALE CONVERTER\n\n\tScaling by a factor 2 means that values of the timing object (position, velocity and acceleration) are multiplied by two.\n\tFor example, if the timing object represents a media offset in seconds, scaling it to milliseconds implies a scaling factor of 1000.\n\n*/\n\nimport TimingObject from './timingobject.js';\n\n\nclass ScaleConverter extends TimingObject {\n    constructor (timingsrc, factor) {\n\t\tsuper(timingsrc);\n\t\tthis._factor = factor;\n        this.eventifyDefine(\"scalechange\", {init:true});\n\t};\n\n    // extend\n    eventifyInitEventArgs(name) {\n        if (name == \"scalechange\") {\n            return [this._factor];\n        } else {\n            return super.eventifyInitEventArgs(name)\n        }\n    }\n\n\t// overrides\n    onUpdateStart(arg) {\n        if (arg.range != undefined) {\n            arg.range = [arg.range[0]*this._factor, arg.range[1]*this._factor];\n        }\n        if (arg.position != undefined) {\n            arg.position *= this._factor;\n        }\n        if (arg.velocity != undefined) {\n            arg.velocity *= this._factor;\n        }\n        if (arg.acceleration != undefined) {\n            arg.acceleration *= this._factor;\n        }\n        return arg;\n    }\n\n\tupdate(arg) {\n\t\tif (arg.position != undefined) {\n            arg.position /= this._factor;\n        }\n\t\tif (arg.velocity != undefined) {\n            arg.velocity /= this._factor;\n        }\n\t\tif (arg.acceleration != undefined) {\n            arg.acceleration /= this._factor;\n        }\n\t\treturn super.update(arg);\n\t};\n\n    get scale() {return this._factor;};\n\n    set scale(factor) {\n        if (factor != this._factor) {\n            // set scale and emulate new event from timingsrc\n            this._factor = factor;\n            this.__handleEvent({\n                ...this.timingsrc.vector,\n                range: this.timingsrc.range\n            });\n            this.eventifyTrigger(\"scalechange\", factor);\n        }\n    }\n}\nexport default ScaleConverter;\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mæhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n\tLOOP CONVERTER\n\n\tThis is a modulo type transformation where the converter will be looping within\n\ta given range. Potentially one could create an associated timing object keeping track of the\n\tloop number.\n*/\n\n\nimport {calculateVector} from '../util/motionutils.js';\nimport TimingObject from './timingobject.js';\n\n\n// ovverride modulo to behave better for negative numbers\nfunction mod(n, m) {\n\treturn ((n % m) + m) % m;\n};\n\nfunction transform(x, range) {\n\tlet skew = range[0];\n\tlet length = range[1] - range[0];\n\treturn skew + mod(x-skew, length);\n}\n\n\n/*\n\tLOOP CONVERTER\n*/\n\nclass LoopConverter extends TimingObject {\n\n\tconstructor(timingsrc, range) {\n\t\tsuper(timingsrc, {timeout:true});\n\t\tthis.__range = range;\n\t};\n\n\tupdate(arg) {\n\t\t// range change - only a local operation\n\t\tif (arg.range != undefined) {\n\t\t\t// implement local range update\n\t\t\tlet [low, high] = arg.range;\n\t\t\tif (low >= high) {\n\t\t\t\tthrow new Error(\"illegal range\", arg.range)\n\t\t\t}\n\t\t\tif (low != this.__range[0] || high != this.__range[1]) {\n\t\t\t\tthis.__range = [low, high];\n\t\t\t\tlet vector = this.timingsrc.query();\n\t\t\t\tvector.position = transform(vector.position, this.__range);\n\t\t\t\tthis.__vector = vector;\n\t\t\t\t// trigger vector change\n\t\t\t\tlet _arg = {range: this.__range, ...this.__vector, live:true};\n\t\t\t\tthis.__dispatchEvents(_arg, true, true);\n\t\t\t}\n\t\t\tdelete arg.range;\n\t\t}\n\t\t// vector change\n\t\tif (arg.position != undefined) {\n\t\t\t// inverse transformation of position, from looper\n\t\t\t// coordinates to timingsrc coordinates\n\t\t\t// preserve relative position diff\n\t\t\tlet now = this.clock.now();\n\t\t\tlet now_vector = calculateVector(this.vector, now);\n\t\t\tlet diff = now_vector.position - arg.position;\n\t\t\tlet now_vector_src = calculateVector(this.timingsrc.vector, now);\n\t\t\targ.position = now_vector_src.position - diff;\n\t\t}\n\t\treturn super.update(arg);\n\t};\n\n\t// overrides\n\tonRangeViolation(vector) {\n\t\t// vector is moving\n\t\tif (vector.position <= this.__range[0]) {\n\t\t\tvector.position = this.__range[1];\n\t\t} else if (this.__range[1] <= vector.position) {\n\t\t\tvector.position = this.__range[0];\n\t\t}\n\t\treturn vector;\n\t};\n\n\t// overrides\n\tonUpdateStart(arg) {\n        if (arg.range != undefined) {\n            // ignore range change from timingsrc\n            // instead, insist that this._range is correct\n            arg.range = this.__range;\n        }\n        if (arg.position != undefined) {\n        \t// vector change\n        \targ.position = transform(arg.position, this.__range);\n        }\n        return arg;\n\t};\n\n}\nexport default LoopConverter;\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mæhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\n\tRANGE CONVERTER\n\n\tThe converter enforce a range on position.\n\n\tIt only has effect if given range is a restriction on the range of the timingsrc.\n\tRange converter will pause on range endpoints if timingsrc leaves the range.\n\tRange converters will continue mirroring timingsrc once it comes into the range.\n*/\n\n\nimport {RangeState, correctRangeState, checkRange} from '../util/motionutils.js';\nimport TimingObject from './timingobject.js';\n\n\nfunction state() {\n\tvar _state = RangeState.INIT;\n\tvar _range = null;\n\tvar is_special_state_change = function (old_state, new_state) {\n\t\t// only state changes between INSIDE and OUTSIDE* are special state changes.\n\t\tif (old_state === RangeState.OUTSIDE_HIGH && new_state === RangeState.OUTSIDE_LOW) return false;\n\t\tif (old_state === RangeState.OUTSIDE_LOW && new_state === RangeState.OUTSIDE_HIGH) return false;\n\t\tif (old_state === RangeState.INIT) return false;\n\t\treturn true;\n\t}\n\tvar get = function () {return _state;};\n\tvar set = function (new_state, new_range) {\n\n\t\tvar absolute = false; // absolute change\n\t\tvar special = false;  // special change\n\n\t\t// check absolute change\n\t\tif (new_state !== _state || new_range !== _range) {\n\t\t\tabsolute = true;\n\t\t}\n\t\t// check special change\n\t\tif (new_state !== _state) {\n\t\t\tspecial = is_special_state_change(_state, new_state);\n\t\t}\n\t\t// range change\n\t\tif (new_range !== _range) {\n\t\t\t_range = new_range;\n\t\t}\n\t\t// state change\n\t\tif (new_state !== _state) {\n\t\t\t_state = new_state;\n\t\t}\n\t\treturn {special:special, absolute:absolute};\n\n\t}\n\treturn {get: get, set:set};\n};\n\n\n/*\n\tRange converter allows a new (smaller) range to be specified.\n\n\t- ignores the range of its timingsrc\n\t- vector change from timingsrc\n\t  - outside own range - drop - set timeout to inside\n\t  - inside own range - normal processing\n\t- extra vector changes (compared to timingsrc)\n\t\t- enter inside\n\t\t- range violation own range\n\t- range updated locally\n\n*/\n\nclass RangeConverter extends TimingObject {\n\n\tconstructor (timingObject, range) {\n\t\tsuper(timingObject, {timeout:true});\n\t\tthis.__state = state();\n\t\tthis.__range = range;\n\t};\n\n\n\tupdate(arg) {\n\t\tthrow Error(\"Not Implemented!\");\n\t\t/*\n\t\t\trange change - only a local operation\n\n\t\t\t\t- need to trigger local processing of new range,\n\t\t\t\tso that range is changed and events triggered\n\t\t\t\t- also need to trigger a reevaluation of\n\t\t\t\tvector from timingsrc vector, for instance, if\n\t\t\t\trange grows while timingsrc is outside, the\n\t\t\t\tposition of the vector needs to change\n\t\t\t\t- cannot do both these things via emulation\n\t\t\t\tof timingsrc event - because rangeconverter\n\t\t\t\tis supposed to ignore range change from timingsrc\n\t\t\t\t- could do both locally, but this would effectively\n\t\t\t\trequire reimplementation of logic in __process\n\t\t\t\t- in addition, this could be a request to update\n\t\t\t\tboth range and vector at the same time, in which case\n\t\t\t\tit would be good to do them both at the same time\n\n\t\t\t- possible solution - somehow let range converter\n\t\t\t  discriminate range changes based on origin?\n\n\t\t*/\n\t\tif (arg.range != undefined) {\n\n\t\t\t// local processing of range change\n\t\t\t// to trigger range change event\n\t\t\tlet _arg = {range: arg.range, ...this.timingsrc.vector, live:true};\n\t\t\tthis.__process(_arg);\n\t\t\t// avoid that range change affects timingsrc\n\t\t\tdelete arg.range;\n\n\t\t}\n\t\treturn super.update(arg);\n\t};\n\n\n\n\t// overrides\n\tonUpdateStart(arg) {\n        if (arg.range != undefined) {\n        \t// ignore range change from timingsrc\n        \t// delete causes update to be dropped\n            delete arg.range;\n        }\n        if (arg.position != undefined) {\n        \t// vector change from timingsrc\n        \tlet {position, velocity, acceleration, timestamp} = arg;\n        \tlet vector = {position, velocity, acceleration, timestamp};\n        \tvector = this.onVectorChange(vector);\n        \tif (vector == undefined) {\n        \t\t// drop because motion is outside\n\t\t\t\t// create new timeout for entering inside\n\t\t\t\tthis.__renewTimeout(this.timingsrc.vector, this.__range);\n\t\t\t\treturn;\n        \t} else {\n        \t\t// regular\n        \t\targ.position = vector.position;\n        \t\targ.velocity = vector.velocity;\n        \t\targ.acceleration = vector.acceleration;\n        \t\targ.timestamp = vector.timestamp;\n        \t}\n        }\n        return arg;\n\t};\n\n\n\tonVectorChange(vector) {\n\t\tvar new_state = correctRangeState(vector, this.__range);\n\t\tvar state_changed = this.__state.set(new_state, this.__range);\n\t\tif (state_changed.special) {\n\t\t\t// state transition between INSIDE and OUTSIDE\n\t\t\tif (this.__state.get() === RangeState.INSIDE) {\n\t\t\t\t// OUTSIDE -> INSIDE, generate fake start event\n\t\t\t\t// vector delivered by timeout\n\t\t\t\t// forward event unchanged\n\t\t\t} else {\n\t\t\t\t// INSIDE -> OUTSIDE, generate fake stop event\n\t\t\t\tvector = checkRange(vector, this.__range);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// no state transition between INSIDE and OUTSIDE\n\t\t\tif (this.__state.get() === RangeState.INSIDE) {\n\t\t\t\t// stay inside or first event inside\n\t\t\t\t// forward event unchanged\n\t\t\t} else {\n\t\t\t\t// stay outside or first event outside\n\t\t\t\t// forward if\n\t\t\t\t// - first event outside\n\t\t\t\t// - skip from outside-high to outside-low\n\t\t\t\t// - skip from outside-low to outside-high\n\t\t\t\t// - range change\n\t\t\t\t// else drop\n\t\t\t\t// - outside-high to outside-high (no range change)\n\t\t\t\t// - outside-low to outside-low (no range change)\n\t\t\t\tif (state_changed.absolute) {\n\t\t\t\t\tvector = checkRange(vector, this.__range);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector;\n\t};\n}\n\nexport default RangeConverter;\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mæhlum Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tTIMESHIFT CONVERTER\n\n\tTimeshift Converter timeshifts a timing object by timeoffset.\n\tPositive timeoffset means that the converter will run ahead of the source timing object.\n\tNegative timeoffset means that the converter will run behind the source timing object.\n\n\tUpdates affect the converter immediately.\n    This means that update vector must be re-calculated\n\tto the value it would have at time-shifted time.\n    Timestamps are not time-shifted, since the motion is still live.\n\tFor instance, (0, 1, ts) becomes (0+(1*timeshift), 1, ts)\n\n\tHowever, this transformation may cause range violation\n\t\t- this happens only when timing object is moving.\n\t\t- implementation requires range converter logic\n\n\t- range is infinite\n*/\n\nimport TimingObject from './timingobject.js';\nimport {calculateVector} from '../util/motionutils.js';\n\n\nclass TimeshiftConverter extends TimingObject {\n\n    constructor (timingsrc, offset) {\n\t\tsuper(timingsrc);\n\t\tthis._offset = offset;\n        this.eventifyDefine(\"offsetchange\", {init:true});\n\t};\n\n    // extend\n    eventifyInitEventArgs(name) {\n        if (name == \"offsetchange\") {\n            return [this._offset];\n        } else {\n            return super.eventifyInitEventArgs(name)\n        }\n    }\n\n    // overrides\n    onUpdateStart(arg) {\n        if (arg.range != undefined) {\n            arg.range = [-Infinity, Infinity];\n        }\n        if (arg.position != undefined) {\n            // calculate timeshifted vector\n            let ts = arg.timestamp;\n            let new_vector = calculateVector(arg, ts + this._offset);\n            arg.position = new_vector.position;\n            arg.velocity = new_vector.velocity;\n            arg.acceleration = new_vector.acceleration;\n            arg.timestamp = ts;\n        }\n        return arg;\n    };\n\n    get offset() {return this._offset;};\n\n    set offset(offset) {\n        if (offset != this._offset) {\n            // set offset and emulate new event from timingsrc\n            this._offset = offset;\n            this.__handleEvent({\n                ...this.timingsrc.vector,\n                range: this.timingsrc.range\n            });\n            this.eventifyTrigger(\"offsetchange\", offset);\n        }\n    }\n\n}\n\nexport default TimeshiftConverter;\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport Interval from './interval.js';\n\n// check if n is a number\nfunction is_number(n) {\n\tvar N = parseFloat(n);\n    return (n==N && !isNaN(N));\n};\n\n\n/*\n    utility function for protecting against duplicates\n*/\nfunction unique(A) {\n    return [...new Set(A)];\n};\n\n\n\n/*\n    batch inserts and removes have two strategies\n    1) change-sort\n    2) splice\n\n    simple rule by measurement\n    splice is better for batchlength <= 100 for both insert and remove\n*/\nfunction resolve_approach(arrayLength, batchLength) {\n    if (arrayLength == 0) {\n        return \"sort\";\n    }\n    return (batchLength <= 100) ? \"splice\" : \"sort\";\n};\n\n\nclass BinarySearchError extends Error {\n\n    constructor(message) {\n        super(message);\n        this.name = \"BinarySearchError\";\n    }\n\n}\n\n\n/*\n\nBINARY SEARCH\n\n- based on sorted list of unique elements\n- implements protection against duplicates\n\n\nPublic API\n- update (remove_elements, insert_elements)\n- lookup (interval) - returns list for all elements\n- remove (interval) - removes elements within interval\n- has (element)     - returns true if element exists with value == element, else false\n- get (element)     - returns element with value if exists, else undefined\n- values ()         - returns iterable for all elements\n- indexOf(element)  - returns index of element\n- indexOfElements(elements)\n- getByIndex(index) - returns element at given index\n\n\n*/\n\nfunction cmp(a, b) {return a-b;};\n\n\nclass BinarySearch {\n\n    constructor(options) {\n        this.array = [];\n        this.options = options || {};\n    }\n\n\n    /**\n     * Binary search on sorted array\n     * @param {*} searchElement The item to search for within the array.\n     * @return {Number} The index of the element which defaults to -1 when not found.\n     */\n    binaryIndexOf(searchElement) {\n        let minIndex = 0;\n        let maxIndex = this.array.length - 1;\n        let currentIndex;\n        let currentElement;\n        while (minIndex <= maxIndex) {\n    \t\tcurrentIndex = (minIndex + maxIndex) / 2 | 0;\n    \t\tcurrentElement = this.array[currentIndex];\n            if (currentElement < searchElement) {\n                minIndex = currentIndex + 1;\n            } else if (currentElement > searchElement) {\n                maxIndex = currentIndex - 1;\n            } else {\n                // found\n    \t\t    return currentIndex;\n    \t\t}\n        }\n        // not found - indicate at what index the element should be inserted\n    \treturn ~maxIndex;\n\n        // NOTE : ambiguity\n\n        /*\n        search for an element that is less than array[0]\n        should return a negative value indicating that the element\n        was not found. Furthermore, as it escapes the while loop\n        the returned value should indicate the index that this element\n        would have had - had it been there - as is the idea of this bitwise\n        operator trick\n\n        so, it follows that search for value of minimum element returns 0 if it exists, and 0 if it does not exists\n        this ambiguity is compensated for in relevant methods\n        */\n    };\n\n\n    /*\n        utility function for resolving ambiguity\n    */\n    isFound(index, x) {\n        if (index > 0) {\n            return true;\n        }\n        if (index == 0 && this.array.length > 0 && this.array[0] == x) {\n            return true;\n        }\n        return false;\n    };\n\n    /*\n        returns index of value or -1\n    */\n    indexOf(x) {\n        var index = this.binaryIndexOf(x);\n        return (this.isFound(index, x)) ? index : -1;\n    };\n\n    indexOfElements(elements) {\n        let x, index;\n        let indexes = [];\n        for (let i=0; i<elements.length; i++) {\n            x = elements[i];\n            index = this.indexOf(x);\n            if (index > -1) {\n                indexes.push(index);\n            }\n        }\n        return indexes;\n    };\n\n    /*\n        element exists with value\n    */\n    has(x) {\n        return (this.indexOf(x) > -1) ? true : false;\n    };\n\n    get(index) {\n        return this.array[index];\n    };\n\n\n\n    /*\n        REMOVE\n        Removes all elements with given values\n        search for each one and splice remove them individually\n        (reverse order)\n\n        INSERT\n        binarysearch and splice\n        insert - binarysearch and splice\n\n        WARNING - there should be no need to insert elements that are already\n        present in the array. This function drops such duplicates\n    */\n    _update_splice(to_remove, to_insert, options) {\n\n        // REMOVE\n        if (this.array.length > 0) {\n            let indexes = this.indexOfElements(to_remove);\n            /*\n                sort indexes to make sure we are removing elements\n                in backwards order\n                optimization\n                - if elements were sorted in the first place this should not be necessary\n            */\n            indexes.sort(function(a,b){return a-b;});\n            for (let i=indexes.length-1; i > -1; i--) {\n                this.array.splice(indexes[i], 1);\n            }\n        }\n\n        // INSERT\n        let x, index;\n        let len = to_insert.length;\n        for (let i=0; i<len; i++) {\n            x = to_insert[i];\n            index = this.binaryIndexOf(x);\n            if (!this.isFound(index, x)) {\n                // insert at correct place\n                this.array.splice(Math.abs(index), 0, x);\n            }\n        }\n    };\n\n\n    /*\n        remove - flag - sort to end and remove\n\n        Removes all elements with given values\n        - visit all elements - set their value to Infinite\n        - sort O(N) - native\n        - splice off Infinity values at end\n\n        insert - concat and sort\n\n        by doing both remove and insert in one operation,\n        sorting can be done only once.\n    */\n    _update_sort(to_remove, to_insert, options) {\n        // REMOVE\n        if (this.array.length > 0 && to_remove.length > 0) {\n            // visit all elements and set their value to undefined\n            // undefined values will be sorted to the end of the array\n            let indexes = this.indexOfElements(to_remove);\n            for (let i=0; i<indexes.length;i++) {\n                this.array[indexes[i]] = undefined;\n            }\n        }\n        // INSERT\n        // concat\n        this.array = this.array.concat(to_insert);\n        // sort\n        this.array.sort(cmp);\n        // remove undefined values at the end if any\n        if (to_remove.length > 0) {\n            let index = this.array.indexOf(undefined);\n            if (index > -1) {\n                this.array.splice(index, this.array.length-index);\n            }\n        }\n        // remove duplicates\n        this.array = unique(this.array);\n    };\n\n\n    /*\n        Update - removing and inserting elements in one operation\n\n        a single element should only be present once in the list, thus avoiding\n        multiple operations to one element. This is presumed solved externally.\n        - also objects must not be members of both lists.\n\n        - internally selects the best method - searchsplice or concatsort\n        - selection based on relative sizes of existing elements and new elements\n\n    */\n    update(to_remove, to_insert, options) {\n        let size = to_remove.length + to_insert.length;\n        if (size == 0) {\n            return;\n        }\n\n        // regular case\n        let approach = resolve_approach(this.array.length, size);\n        if (approach == \"splice\") {\n            this._update_splice(to_remove, to_insert, options);\n        } else if (approach == \"sort\"){\n            this._update_sort(to_remove, to_insert, options);\n        }\n    };\n\n\n    /*\n        Accessors\n    */\n\n    getMinimum() {\n        return (this.array.length > 0) ? this.array[0] : undefined;\n    };\n\n    getMaximum = function () {\n        return (this.array.length > 0) ? this.array[this.array.length - 1] : undefined;\n    };\n\n\n    /*\n        Internal search functions\n    */\n\n    /*\n       Find index of largest value less than x\n       Returns -1 if noe values exist that are less than x\n     */\n    ltIndexOf(x) {\n        var i = this.binaryIndexOf(x);\n        if (this.isFound(i, x)) {\n            /*\n                found - x is found on index i\n                consider element to the left\n                if we are at the left end of the array nothing is found\n                return -1\n            */\n            if (i > 0) {\n                return i-1;\n            } else {\n                return -1;\n            }\n        } else {\n            /*\n                not found - Math.abs(i) is index where x should be inserted\n                => Math.abs(i) - 1 is the largest value less than x\n            */\n            return Math.abs(i)-1;\n        }\n    };\n\n    /*\n       Find index of rightmost value less than x or equal to x\n       Returns -1 if noe values exist that are less than x or equal to x\n     */\n    leIndexOf(x) {\n        var i = this.binaryIndexOf(x);\n        if (this.isFound(i, x)) {\n            /*\n                element found\n            */\n            return i;\n        } else {\n            // not found - consider element to the left\n            i = Math.abs(i) - 1;\n            return (i >= 0) ? i : -1;\n        }\n    };\n\n    /*\n       \tFind index of leftmost value greater than x\n       \tReturns -1 if no values exist that are greater than x\n    */\n\n    gtIndexOf(x) {\n        var i = this.binaryIndexOf(x);\n        if (this.isFound(i, x)) {\n            /*\n                found - x is found on index i\n                if there are no elements to the right return -1\n            */\n            if (i < this.array.length -1) {\n                return i+1;\n            } else {\n                return -1;\n            }\n        } else {\n            /*\n                not found - Math.abs(i) is index where x should be inserted\n                => Math.abs(i) is the smallest value greater than x\n                unless we hit the end of the array, in which cas no smalles value\n                exist which is greater than x\n            */\n            let idx = Math.abs(i);\n            return (idx < this.array.length) ? idx : -1;\n        }\n    };\n\n\n    /*\n       Find index of leftmost value which is greater than x or equal to x\n       Returns -1 if noe values exist that are greater than x or equal to x\n     */\n\n    geIndexOf(x) {\n        var i = this.binaryIndexOf(x);\n        if (this.isFound(i, x)) {\n            /*\n                found element\n            */\n            return i;\n        } else {\n            // not found - consider the element where x would be inserted\n            i = Math.abs(i);\n            return (i<this.array.length) ? i : -1;\n        }\n    };\n\n    /*\n        lookup start and end indexes of elements within interval\n        for use with slice operation\n        returns undefined if no elements are found\n    */\n    lookupIndexes(interval) {\n        if (interval === undefined)\n            interval = new Interval(-Infinity, Infinity, true, true);\n        if (interval instanceof Interval === false)\n            throw new BinarySearchError(\"lookup requires Interval argument\");\n\n        // interval represents a single point\n        if (interval.singular) {\n            let index = this.indexOf(interval.low);\n            if (index > -1) {\n                return [index, index + 1];\n            } else {\n                return [undefined, undefined];\n            }\n        }\n\n        // regular non-singular interval\n        var start_index = -1, end_index = -1;\n        if (interval.lowInclude) {\n            start_index = this.geIndexOf(interval.low);\n        } else {\n            start_index = this.gtIndexOf(interval.low);\n        }\n        if (start_index === -1) {\n            return [undefined, undefined];\n        }\n        if (interval.highInclude) {\n            end_index = this.leIndexOf(interval.high);\n        } else {\n            end_index = this.ltIndexOf(interval.high);\n        }\n        if (end_index === -1) { // not reachable - I think\n            return [undefined, undefined];\n        }\n        return [start_index, end_index + 1];\n    };\n\n\n    /*\n        lookup by interval\n    */\n    lookup(interval) {\n        let [start, end] = this.lookupIndexes(interval);\n        return (start != undefined) ? this.array.slice(start, end) : [];\n    };\n\n    /*\n        remove by interval\n    */\n    remove(interval) {\n        let [start, end] = this.lookupIndexes(interval);\n        return (start != undefined) ? this.array.splice(start, end-start) : [];\n    };\n\n\n    slice(start, end) {\n        return this.array.slice(start, end);\n    };\n\n    splice(start, length) {\n        return this.array.splice(start, length);\n    };\n\n\n\n    /*\n        method for removing multiple closely placed elements in place\n        - removeList is sorted\n        - changes only affect the part of the index between first and last element\n        - move remaining elements to the left, remove elements with a single splice\n        - efficent if removelist references elements that are close to eachother\n    */\n\n    removeInSlice(removeList) {\n        if (removeList.length == 0){\n            return;\n        }\n        const low = removeList[0];\n        const high = removeList[removeList.length-1];\n        let [start, end] = this.lookupIndexes(new Interval(low, high, true, true));\n\n        let rd_ptr = start;\n        let wr_ptr = start;\n        let rm_ptr = 0;\n\n        while (rd_ptr < end) {\n            let rd_elem = this.array[rd_ptr];\n            let rm_elem = removeList[rm_ptr];\n            if (rd_elem < rm_elem) {\n                this.array[wr_ptr] = this.array[rd_ptr];\n                wr_ptr++;\n                rd_ptr++;\n            } else if (rd_elem == rm_elem) {\n                rd_ptr++;\n                rm_ptr++;\n            } else {\n                // rd_elem > rm_elem\n                rm_ptr++;\n            }\n            if (rm_ptr == removeList.length) {\n                break\n            }\n        }\n        this.array.splice(wr_ptr, rd_ptr-wr_ptr);\n    };\n\n\n    values() {\n        return this.array.values();\n    };\n\n    clear() {\n        this.array = [];\n    };\n\n    get length () {\n        return this.array.length;\n    }\n\n}\n\nexport default BinarySearch;\n\n\n\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nimport * as utils from '../util/utils.js';\nimport endpoint from '../util/endpoint.js';\nimport Interval from '../util/interval.js';\nimport eventify from '../util/eventify.js';\nimport BinarySearch from '../util/binarysearch.js';\n\nconst Relation = Interval.Relation;\n\n/*\n    UTILITY\n*/\n\n\n/*\n    Add cue to array\n    - does not add if cue already exists\n    - returns array length\n*/\nvar addCueToArray = function (arr, cue) {\n    // cue equality defined by key property\n    if (arr.length == 0) {\n        arr.push(cue);\n    } else {\n        let idx = arr.findIndex(function (_cue) {\n            return _cue.key == cue.key;\n        });\n        if (idx == -1) {\n            arr.push(cue);\n        }\n    }\n    return arr.length;\n};\n\n/*\n    Remove cue from array\n    - noop if cue does not exist\n    - returns array empty\n*/\nvar removeCueFromArray = function (arr, cue) {\n    // cue equality defined by key property\n    if (arr.length == 1) {\n        if (arr[0].key == cue.key) {\n            arr.shift();\n        }\n        return arr.length == 0;\n    }\n    else if (arr.length == 0) {\n        return true;\n    } else {\n        let idx = arr.findIndex(function (_cue) {\n            return _cue.key == cue.key;\n        });\n        if (idx > -1) {\n            arr.splice(idx, 1);\n        }\n        return arr.length == 0;\n    }\n};\n\n/*\n    Setup ID's for cue buckets.\n*/\nconst CueBucketIds = [0, 10, 100, 1000, 10000, 100000, Infinity];\nvar getCueBucketId = function (length) {\n    for (let i=0; i<CueBucketIds.length; i++) {\n        if (length <= CueBucketIds[i]) {\n            return CueBucketIds[i];\n        }\n    }\n};\n\n\n/*\n    Delta\n\n    Used to represent statechanges in batchMap,\n    for intervals and data.\n*/\nconst Delta = Object.freeze({\n    NOOP: 0,\n    INSERT: 1,\n    REPLACE: 2,\n    DELETE: 3\n});\n\n/*\n    make a shallow copy of a cue\n*/\nfunction cue_copy(cue) {\n    if (cue == undefined) {\n        return;\n    }\n    return {\n        key: cue.key,\n        interval: cue.interval,\n        data: cue.data\n    };\n}\n\n/*\n    Characterize the transition from cue_a to cue_b\n    in terms of delta values for interval and data\n\n    For instance, interval has\n    - INSERT: value not in a but in b\n    - DELETE: value in a but not in b\n    - REPLACE: value in a and in be and not equal\n    - NOOP: either remains undefined or remains equal\n\n    optional equals function for data comparison\n    otherwise simple object equality (==) is used\n*/\nfunction cue_delta(cue_a, cue_b, equals) {\n    let interval_delta, data_delta, eq;\n    // interval delta\n    let a_interval_defined = cue_a != undefined && cue_a.interval != undefined;\n    let b_interval_defined = cue_b != undefined && cue_b.interval != undefined;\n    if (!a_interval_defined && !b_interval_defined) {\n        interval_delta = Delta.NOOP;\n    } else if (!a_interval_defined) {\n        interval_delta = Delta.INSERT;\n    } else if (!b_interval_defined) {\n        interval_delta = Delta.DELETE;\n    } else {\n        // check interval equality\n        eq = cue_a.interval.equals(cue_b.interval);\n        interval_delta = (eq) ? Delta.NOOP : Delta.REPLACE;\n    }\n    // data delta\n    let a_data_defined = cue_a != undefined && cue_a.data != undefined;\n    let b_data_defined = cue_b != undefined && cue_b.data != undefined;\n    if (!a_data_defined && !b_data_defined) {\n        data_delta = Delta.NOOP;\n    } else if (!a_data_defined) {\n        data_delta = Delta.INSERT;\n    } else if (!b_data_defined) {\n        data_delta = Delta.DELETE;\n    } else {\n        // check data equality\n        if (equals) {\n            eq = equals(cue_a.data, cue_b.data);\n        } else {\n            eq = utils.object_equals(cue_a.data, cue_b.data);\n        }\n        data_delta = (eq) ? Delta.NOOP : Delta.REPLACE;\n    }\n    return {interval: interval_delta, data: data_delta};\n}\n\n\n\n/*\n    CUE ORDERING AND SORTING\n*/\n\nfunction cue_cmp_forwards (cue_a, cue_b) {\n    return Interval.cmpLow(cue_a.iterval, cue_b.interval);\n}\n\nfunction cue_cmp_backwards (cue_a, cue_b) {\n    return -1 * Interval.cmpHigh(cue_a.iterval, cue_b.interval);\n}\n\nfunction sort_cues (cues, direction=0) {\n    if (direction >= 0) {\n        cues.sort(cue_cmp_forwards);\n    } else {\n        cuess.sort(cue_cmp_backwards);\n    }\n}\n\n\n/*\n    this implements Dataset, a data collection supporting\n    efficient lookup of cues tied to intervals on the timeline\n\n    - cues may be tied to one or two points on the timeline, this\n      is expressed by an Interval.\n    - cues are indexed both by key and by intervals\n    - the interval index is divided into a set of CueBuckets,\n      based on cue interval length, for efficient lookup\n*/\n\nclass Dataset {\n\n    static sort_cues = sort_cues;\n    static Delta = Delta;\n    static cue_delta = cue_delta;\n\n    constructor() {\n        /*\n            efficient lookup of cues by key\n            key -> cue\n        */\n        this._cueMap = new Map();\n\n        /*\n            Initialise set of CueBuckets\n            Each CueBucket is responsible for cues of a certain length\n        */\n        this._cueBuckets = new Map();  // CueBucketId -> CueBucket\n        for (let i=0; i<CueBucketIds.length; i++) {\n            let cueBucketId = CueBucketIds[i];\n            this._cueBuckets.set(cueBucketId, new CueBucket(cueBucketId));\n        }\n\n        // Inline update callbacks\n        this._update_callbacks = [];\n\n        // Change event\n        eventify.eventifyInstance(this);\n        this.eventifyDefine(\"update\", {init:true});\n        this.eventifyDefine(\"change\", {init:true});\n        this.eventifyDefine(\"remove\", {init:false});\n    };\n\n\n    /*\n        SIZE\n        Number of cues managed by dataset\n    */\n    get size () {\n        return this._cueMap.size;\n    }\n\n\n    /***************************************************************\n        EVENTIFY\n\n        Immediate events\n    */\n\n    eventifyInitEventArgs = function (name) {\n        if (name == \"update\" || name == \"change\") {\n            let events = [...this.values()].map(cue => {\n                return {key:cue.key, new:cue, old:undefined};\n            });\n            return (name == \"update\") ? [events] : events;\n        }\n    };\n\n\n    /*\n        Event Notification\n\n    */\n    _notifyEvents(events) {\n        // event notification\n        if (events.length == 0) {\n            return;\n        }\n        const has_update_subs = this.eventifySubscriptions(\"update\").length > 0;\n        const has_remove_subs = this.eventifySubscriptions(\"remove\").length > 0;\n        const has_change_subs = this.eventifySubscriptions(\"change\").length > 0;\n        // update\n        if (has_update_subs) {\n            this.eventifyTrigger(\"update\", events);\n        }\n        // change, remove\n        if (has_remove_subs || has_change_subs) {\n            for (let item of events) {\n                if (item.new == undefined) {\n                    if (has_remove_subs) {\n                        this.eventifyTrigger(\"remove\", item);\n                    }\n                } else {\n                    if (has_change_subs) {\n                        this.eventifyTrigger(\"change\", item);\n                    }\n                }\n            }\n        }\n    }\n\n\n    /***************************************************************\n        UPDATE CALLBACKS\n    */\n\n    add_callback (handler) {\n        let handle = {\n            handler: handler\n        }\n        this._update_callbacks.push(handle);\n        return handle;\n    };\n\n\n    del_callback (handle) {\n        let index = this._update_callbacks.indexof(handle);\n        if (index > -1) {\n            this._update_callbacks.splice(index, 1);\n        }\n    };\n\n\n    _notify_callbacks (batchMap, relevanceInterval) {\n        this._update_callbacks.forEach(function(handle) {\n            handle.handler(batchMap, relevanceInterval);\n        });\n    };\n\n\n    /***************************************************************\n        UPDATE\n\n        - insert, replace or delete cues\n\n        update(cues, equals, check)\n\n        <cues> ordered list of cues to be updated\n        <equals> - equality function for data objects\n        <check> - check cue integrity if true\n\n        cue = {\n            key:key,\n            interval: Interval,\n            data: data\n        }\n\n        required\n        - cue.key property is defined and value is != undefined\n        - if cue.interval != undefined, it must be instance of Interval\n\n        EXAMPLES\n\n        // INSERT (no pre-existing cue)\n\n        cue = {key:1, interval: new Interval(3,4), data: {}}\n        // insert cue with only interval\n        cue = {key:1, interval: new Interval(3,4)}\n        // insert cue with only data\n        cue = {key:1, data: {}}\n\n\n        // REPLACE (pre-existing cue)\n        preexisting_cue = {key:1, interval: new Interval(3,4), data: {}}\n\n        cue = {key:1, interval: new Interval(3,5), data: {foo:\"bar\"}}\n        // replace interval, keep data\n        cue = {key:1, interval: new Interval(3,5)}\n        // replace interval, delete data\n        cue = {key:1, interval: new Interval(3,5), data: undefined\n        // replace data, keep interval\n        cue = {key:1, data: {foo:\"bar\"}}\n        // replace data, delete interval\n        cue = {key:1, interval: undefined, data: {foo:\"bar\"}}\n\n        // DELETE (pre-existing)\n        cue = {key:1}\n        // delete interval, keep data\n        cue = {key:1, interval: undefined}\n        // delete data, keep interval\n        cue = {key:1, data: undefined}\n\n\n        Update returns a list of event items - describes the effects of an update.\n            {\n                new: new_cue,\n                old: old_cue,\n                delta: {\n                    interval: Delta,\n                    data: Delta\n                }\n            }\n\n        with independent delta values for interval and data:\n        Delta.NOOP: 0\n        Delta.INSERT: 1\n        Delta.REPLACE: 2\n        Delta.DELETE: 3\n\n        Duplicates\n        - if there are multiple cue operations for the same key,\n          within the same batch of cues,\n          these will be processed in order.\n\n        - The old cue will always be the state of the cue,\n          before the batch started.\n\n        - The returned delta values will be calcultated relative to\n          the cue before the batch started (old).\n\n          This way, external mirroring observers may will be able to\n          replicate the effects of the update operation.\n\n    ***************************************************************/\n\n    update(cues, options) {\n        const batchMap = new Map();\n        let current_cue;\n        let has_interval, has_data;\n        let init = this._cueMap.size == 0;\n        // options\n        options = options || {};\n        // check is false by default\n        if (options.check == undefined) {\n            options.check = false;\n        }\n        // chaining is true by default\n        if (options.chaining == undefined) {\n            options.chaining = true;\n        }\n\n        if (!utils.isIterable(cues)) {\n            cues = [cues];\n        }\n\n        /***********************************************************\n            process all cues\n        ***********************************************************/\n        for (let cue of cues) {\n\n            /*******************************************************\n                check validity of cue argument\n            *******************************************************/\n\n            if (options.check) {\n                if (!(cue) || !cue.hasOwnProperty(\"key\") || cue.key == undefined) {\n                    throw new Error(\"illegal cue\", cue);\n                }\n            }\n            has_interval = cue.hasOwnProperty(\"interval\");\n            has_data = cue.hasOwnProperty(\"data\");\n            if (options.check && has_interval) {\n                if (!cue.interval instanceof Interval) {\n                    throw new Error(\"interval must be Interval\");\n                }\n            }\n\n            /*******************************************************\n                adjust cue so that it correctly represents\n                the new cue to replace the current cue\n                - includeds preservation of values from current cue\n            *******************************************************/\n\n            current_cue = (init) ? undefined : this._cueMap.get(cue.key);\n            if (current_cue == undefined) {\n                // make sure properties are defined\n                if (!has_interval) {\n                    cue.interval = undefined;\n                }\n                if (!has_data) {\n                    cue.data = undefined;\n                }\n            } else if (current_cue != undefined) {\n                if (!has_interval && !has_data) {\n                    // make sure properties are defined\n                    cue.interval = undefined;\n                    cue.data = undefined;\n                } else if (!has_data) {\n                    // REPLACE_INTERVAL, preserve data\n                    cue.data = current_cue.data;\n                } else if (!has_interval) {\n                    // REPLACE_DATA, preserve interval\n                    cue.interval = current_cue.interval;\n                } else {\n                    // REPLACE CUE\n                }\n            }\n\n            /*******************************************************\n                update cue\n                - update cueMap\n                - update cueBuckets\n                - create batchMap\n            *******************************************************/\n\n            this._update_cue(batchMap, current_cue, cue, options);\n        }\n        // flush all buckets so updates take effect\n        this._call_buckets(\"flush\");\n        if (batchMap.size > 0) {\n\n            /*\n                create events without delta property\n                and accumulate relevance interval for batch\n            */\n            let relevance = {low: Infinity, high: -Infinity};\n\n            // create list of events and remove delta property\n            let events = [...batchMap.values()].map(item => {\n                if (item.new && item.new.interval) {\n                    relevance.low = endpoint.min(relevance.low, item.new.interval.endpointLow);\n                    relevance.high = endpoint.max(relevance.high, item.new.interval.endpointHigh);\n                }\n                if (item.old && item.old.interval) {\n                    relevance.low = endpoint.min(relevance.low, item.old.interval.endpointLow);\n                    relevance.high = endpoint.max(relevance.high, item.old.interval.endpointHigh);\n                }\n                return {key:item.key, new:item.new, old:item.old};\n            });\n            // event notification\n            this._notifyEvents(events);\n\n            // create relevance Interval\n            let relevanceInterval = undefined;\n            if (relevance.low != Infinity) {\n                relevanceInterval = Interval.fromEndpoints(relevance.low, relevance.high);\n            }\n\n            /*\n                notify sequencer last so that change events\n                from the dataset will be applied before change\n                events from sequencers.\n            */\n            this._notify_callbacks(batchMap, relevanceInterval);\n            return events;\n        }\n        return [];\n    };\n\n\n\n    /***************************************************************\n        UPDATE CUE\n\n        update operation for a single cue\n\n        - update cueMap\n        - generate entry for batchMap\n        - update CueBucket\n    ***************************************************************/\n\n    _update_cue(batchMap, current_cue, cue, options) {\n        let old_cue, new_cue;\n        let item, _item;\n        let oldCueBucket, newCueBucket;\n        let low_changed, high_changed;\n        let remove_needed, add_needed;\n        let equals = options.equals;\n        let chaining = options.chaining;\n\n        // check for equality\n        let delta = cue_delta(current_cue, cue, equals);\n\n        // (NOOP, NOOP)\n        if (delta.interval == Delta.NOOP && delta.data == Delta.NOOP) {\n            item = {\n                key:cue.key, new:current_cue,\n                old:current_cue, delta: delta\n            }\n            batchMap.set(cue.key, item);\n            return;\n        }\n\n        /***********************************************************\n            update cueMap and batchMap\n        ***********************************************************/\n\n        if (current_cue == undefined) {\n            // INSERT - add cue object to cueMap\n            old_cue = undefined;\n            new_cue = cue;\n            this._cueMap.set(cue.key, new_cue);\n        } else if (cue.interval == undefined && cue.data == undefined) {\n            // DELETE - remove cue object from cueMap\n            old_cue = current_cue;\n            new_cue = undefined;\n            this._cueMap.delete(cue.key);\n        } else {\n            // REPLACE\n            // in-place modification of current cue\n            // copy old cue before modification\n            old_cue = cue_copy(current_cue);\n            new_cue = current_cue;\n            // update current cue in place\n            new_cue.interval = cue.interval;\n            new_cue.data = cue.data;\n        }\n        item = {key:cue.key, new:new_cue, old:old_cue, delta:delta};\n\n        /*\n            if this item has been set earlier in batchMap\n            restore the correct old_cue by getting it from\n            the previous batchMap item\n\n            recalculate delta relative to old_cue\n            - this delta is only for sequencers\n            - continue processing with the original delta defined\n            above, as this is required to correctly change cueBuckets\n            which have already been affected by previous item.\n        */\n        if (chaining) {\n            _item = batchMap.get(cue.key);\n            if (_item != undefined) {\n                item.old = _item.old;\n                item.delta = cue_delta(new_cue, item.old, equals);\n            }\n        }\n\n        batchMap.set(cue.key, item)\n\n        /***********************************************************\n            update cueBuckets\n\n            - use delta.interval to avoid unnessesary changes\n\n            - interval may change in several ways:\n                - low changed\n                - high changed\n                - low and high changed\n            - changed intervals may stay in bucket or change bucket:\n            - changing to/from singular may require special consideration\n              with respect to how many endpoints are being updated\n                - singular -> singular\n                - singular -> regular\n                - regular -> singular\n                - regular -> regular\n            - changes to interval.lowInclude and interval highInclude\n              do not require any changes to CueBuckets, as long\n              as interval.low and interval.high values stay unchanged.\n        ***********************************************************/\n\n        if (delta.interval == Delta.NOOP) {\n            // data changes are reflected in cueMap changes,\n            // since data changes are made in-place, these\n            // changes will be visible in cues registered in\n            // CueBuckets\n            return;\n        } else if (delta.interval == Delta.INSERT) {\n            remove_needed = false;\n            add_needed = true;\n            low_changed = true;\n            high_changed = true;\n        } else if (delta.interval == Delta.DELETE) {\n            remove_needed = true;\n            add_needed = false;\n            low_changed = true;\n            high_changed = true;\n        } else if (delta.interval == Delta.REPLACE) {\n            remove_needed = true;\n            add_needed = true;\n            low_changed = item.new.interval.low != item.old.interval.low;\n            high_changed = item.new.interval.high != item.old.interval.high;\n        }\n\n        /*\n            old cue and new cue might not belong to the same cue bucket\n        */\n        if (remove_needed){\n            let old_bid = getCueBucketId(item.old.interval.length);\n            oldCueBucket = this._cueBuckets.get(old_bid);\n        }\n        if (add_needed) {\n            let new_bid = getCueBucketId(item.new.interval.length);\n            newCueBucket = this._cueBuckets.get(new_bid);\n        }\n\n        /*\n            if old CueBucket is different from the new cue Buckets\n            both low and high must be moved, even it one was not\n            changed\n        */\n        if (oldCueBucket && newCueBucket) {\n            if (oldCueBucket != newCueBucket) {\n                remove_needed = true;\n                add_needed = true;\n                low_changed = true;\n                high_changed = true;\n            }\n        }\n\n        /*\n            dispatch add and remove operations for interval points\n\n            cues in CueBucket may be removed using a copy of the cue,\n            because remove is by key.\n\n            cues added to CueBucket must be the correct object\n            (current_cue), so that later in-place modifications become\n            reflected in CueBucket.\n            batchMap item.new is the current cue object.\n        */\n\n        // update low point - if changed\n        if (low_changed) {\n            if (remove_needed) {\n                // console.log(\"remove old low\", item.old.interval.low);\n                oldCueBucket.del_endpoint(item.old.interval.low, item.old);\n            }\n            if (add_needed) {\n                // console.log(\"add new low\", item.new.interval.low);\n                newCueBucket.add_endpoint(item.new.interval.low, item.new);\n            }\n        }\n        // update high point - if changed\n        if (high_changed) {\n            if (remove_needed && !item.old.interval.singular) {\n                // console.log(\"remove old high\", item.old.interval.high);\n                oldCueBucket.del_endpoint(item.old.interval.high, item.old);\n            }\n            if (add_needed && !item.new.interval.singular) {\n                // console.log(\"add new high\", item.new.interval.high);\n                newCueBucket.add_endpoint(item.new.interval.high, item.new);\n            }\n        }\n    }\n\n\n    /*\n        INTERNAL FUNCTION\n        execute method across all cue buckets\n        and aggregate results\n    */\n    _call_buckets(method, ...args) {\n        const arrays = [];\n        for (let cueBucket of this._cueBuckets.values()) {\n            let cues = cueBucket[method](...args);\n            if (cues != undefined && cues.length > 0) {\n                arrays.push(cues);\n            }\n        }\n        return utils.array_concat(arrays);\n    };\n\n    /*\n        LOOKUP ENDPOINTS\n\n        returns (endpoint, cue) for all endpoints covered by given interval\n\n        returns:\n            - [{endpoint: endpoint, cue:cue}]\n    */\n\n    lookup_endpoints(interval) {\n        return this._call_buckets(\"lookup_endpoints\", interval);\n    };\n\n\n    /*\n        LOOKUP\n    */\n\n    lookup(interval, mask) {\n        return this._call_buckets(\"lookup\", interval, mask);\n    };\n\n\n    /*\n        REMOVE CUES BY INTERVAL\n    */\n    lookup_delete(interval, mask) {\n        const cues = this._call_buckets(\"lookup_delete\", interval, mask);\n        // remove from cueMap and make events\n        const events = [];\n        let cue;\n        for (let i=0; i<cues.length; i++) {\n            cue = cues[i];\n            this._cueMap.delete(cue.key);\n            // check for equality\n            events.push({key:cue.key, new: undefined, old: cue});\n        }\n        // event notification\n        this._notifyEvents(events);\n        return events;\n    };\n\n    /*\n        CLEAR ALL CUES\n    */\n    clear() {\n        // clear cue Buckets\n        this._call_buckets(\"clear\");\n        // clear cueMap\n        let cueMap = this._cueMap;\n        this._cueMap = new Map();\n        // create change events for all cues\n        const events = [];\n        for (let cue of cueMap.values()) {\n            events.push({key: cue.key, new: undefined, old: cue});\n        }\n        // event notification\n        this._notifyEvents(events);\n        return events;\n    };\n\n\n    /*\n        Map accessors\n    */\n\n    has(key) {\n        return this._cueMap.has(key);\n    };\n\n    get(key) {\n        return this._cueMap.get(key);\n    };\n\n    keys() {\n        return this._cueMap.keys();\n    };\n\n    values() {\n        return this._cueMap.values();\n    };\n\n    entries() {\n        return this._cueMap.entries();\n    }\n\n\n    /*\n        utility\n    */\n    integrity() {\n        const res = this._call_buckets(\"integrity\");\n\n        // sum up cues and points\n        let cues = [];\n        let points = [];\n        for (let bucketInfo of res.values()) {\n            cues.push(bucketInfo.cues);\n            points.push(bucketInfo.points);\n        }\n        cues = [].concat(...cues);\n        points = [].concat(...points);\n        // remove point duplicates if any\n        points = [...new Set(points)];\n\n        if (cues.length != this._cueMap.size) {\n            throw new Error(\"inconsistent cue count cueMap and aggregate cueBuckets \" + cues-this._cueMap.size);\n        }\n\n        // check that cues are the same\n        for (let cue of cues.values()) {\n            if (!this._cueMap.has(cue.key)) {\n                throw new Error(\"inconsistent cues cueMap and aggregate cueBuckets\");\n            }\n        }\n\n        return {\n            cues: cues.length,\n            points: points.length\n        };\n    };\n\n}\n\neventify.eventifyPrototype(Dataset.prototype);\n\n\n\n\n/*\n    CueBucket is a bucket of cues limited to specific length\n*/\n\n\nclass CueBucket {\n\n\n    constructor(maxLength) {\n\n        // max length of cues in this bucket\n        this._maxLength = maxLength;\n\n        /*\n            pointMap maintains the associations between values (points on\n            the timeline) and cues that reference such points. A single point value may be\n            referenced by multiple cues, so one point value maps to a list of cues.\n\n            value -> [cue, ....]\n        */\n        this._pointMap = new Map();\n\n\n        /*\n            pointIndex maintains a sorted list of numbers for efficient lookup.\n            A large volume of insert and remove operations may be problematic\n            with respect to performance, so the implementation seeks to\n            do a single bulk update on this structure, for each batch of cue\n            operations (i.e. each invocations of addCues). In order to do this\n            all cue operations are processed to calculate a single batch\n            of deletes and a single batch of inserts which then will be applied to\n            the pointIndex in one atomic operation.\n\n            [1.2, 3, 4, 8.1, ....]\n        */\n        this._pointIndex = new BinarySearch();\n\n        // bookeeping during batch processing\n        this._created = new Set(); // point\n        this._dirty = new Set(); // point\n\n    };\n\n\n    /*\n\n        ENDPOINT BATCH PROCESSING\n\n        Needs to translate endpoint operations into a minimum set of\n        operations on the pointIndex.\n\n        To do this, we need to record points that are created and\n        points that are removed.\n\n        The total difference that the batch of cue operations\n        amounts to is expressed as one list of values to be\n        deleted, and and one list of values to be inserted.\n        The update operation of the pointIndex will process both\n        in one atomic operation.\n\n        On flush both the pointMap and the pointIndex will be brought\n        up to speed\n\n        created and dirty are used for bookeeping during\n        processing of a cue batch. They are needed to\n        create the correct diff operation to be applied on pointIndex.\n\n        created : includes values that were not in pointMap\n        before current batch was processed\n\n        dirty : includes values that were in pointMap\n        before current batch was processed, and that\n        have been become empty at least at one point during cue\n        processing.\n\n        created and dirty are used as temporary alternatives to pointMap.\n        after the cue processing, pointmap will updated based on the\n        contents of these two.\n\n        process buffers operations for pointMap and index so that\n        all operations may be applied in one batch. This happens in flush\n    */\n\n    add_endpoint(point, cue) {\n        let init = (this._pointMap.size == 0);\n        let cues = (init) ? undefined : this._pointMap.get(point);\n        if (cues == undefined) {\n            this._pointMap.set(point, [cue]);\n            this._created.add(point);\n        } else {\n            cues.push(cue);\n            //addCueToArray(cues, cue);\n        }\n    }\n\n    del_endpoint(point, cue) {\n        let init = (this._pointMap.size == 0);\n        let cues = (init) ? undefined : this._pointMap.get(point);\n        if (cues != undefined) {\n            let empty = removeCueFromArray(cues, cue);\n            if (empty) {\n                this._dirty.add(point);\n            }\n        }\n    };\n\n    /*\n        Batch processing is completed\n        Commit changes to pointIndex and pointMap.\n\n        pointMap\n        - update with contents of created\n\n        pointIndex\n        - points to delete - dirty and empty\n        - points to insert - created and non-empty\n\n        it is possible that a cue ends up in both created and dirty\n\n    */\n    flush() {\n        if (this._created.size == 0 && this._dirty.size == 0) {\n            return;\n        }\n\n        // update pointIndex\n        let to_remove = [];\n        let to_insert = [];\n        for (let point of this._created.values()) {\n            let cues = this._pointMap.get(point);\n            if (cues.length > 0) {\n                to_insert.push(point);\n            } else {\n                this._pointMap.delete(point);\n            }\n        }\n        for (let point of this._dirty.values()) {\n            let cues = this._pointMap.get(point);\n            if (cues == undefined) {\n                // point already deleted from created set - ignore\n                continue;\n            }\n            if (cues.length == 0) {\n                to_remove.push(point);\n                this._pointMap.delete(point);\n            }\n        }\n        this._pointIndex.update(to_remove, to_insert);\n        // cleanup\n        this._created.clear();\n        this._dirty.clear();\n    };\n\n\n    /*\n        LOOKUP_ENDPOINTS\n\n        returns all (endpoint, cue) pairs where\n            - endpoint is a cue endpoint (cue.endpointLow or cue.endpointHigh)\n            - endpoint is INSIDE search interval\n            - [{endpoint:endpoint, cue: cue}]\n\n        - a given endpoint may appear multiple times in the result,\n          as multiple cues may be tied to the same endpoint\n        - a given cue may appear two times in the result, if\n          both cue.endpointLow and cue.endpointHigh are both INSIDE interval\n        - a singular cue will appear only once\n        - ordering: no specific order is guaranteed\n          - results are concatenated from multiple CueBuckets\n          - internally in a single CueBucket\n            - no defined order for cues tied to the same endpoint\n          - the natural order is endpoint order\n            - but this can be added on the outside if needed\n            - no order is defined if two cues have exactly the\n              same endpoint\n\n    */\n\n    lookup_endpoints(interval) {\n        const broader_interval = new Interval(interval.low, interval.high, true, true);\n        const points = this._pointIndex.lookup(broader_interval);\n        const result = [];\n        const len = points.length;\n        let point, _endpoint;\n        for (let i=0; i<len; i++) {\n            point = points[i];\n            this._pointMap.get(point)\n                .forEach(function (cue) {\n                    /*\n                        figure out if point is endpoint low or high\n                        include cue if the endpoint is inside search interval\n                    */\n                    if (point == cue.interval.low) {\n                        _endpoint = cue.interval.endpointLow;\n                    } else if (point == cue.interval.high) {\n                        _endpoint = cue.interval.endpointHigh;\n                    } else {\n                        console.log(point)\n                        console.log(cue)\n                        throw new Error(\"fatal: point cue mismatch\");\n                    }\n                    if (interval.covers_endpoint(_endpoint)) {\n                        result.push({endpoint:_endpoint, cue:cue});\n                    }\n                });\n        }\n        return result;\n    }\n\n\n    /*\n        _LOOKUP CUES\n\n        Internal function, used by LOOKUP.\n\n        Return list of cues\n        - all cues with at least one endpoint value v,\n          where interval.low <= v <= interval.high\n        - no duplicates\n\n        Note - some cues may be outside the search interval\n        e.g. if the search interval is [.., 4) then\n        (4, ...] will be returned, even if this strictly\n        is OUTSIDE_RIGHT the search interval.\n        This is necessary in lookup for correct calculation of covers\n        from left_interval.\n    */\n\n    _lookup_cues(interval) {\n        const broader_interval = new Interval(interval.low, interval.high, true, true);\n        const points = this._pointIndex.lookup(broader_interval);\n        const len = points.length;\n        const cueSet = new Set();\n        const result = [];\n        let low_inside, high_inside;\n        for (let i=0; i<len; i++) {\n            this._pointMap.get(points[i])\n                .forEach(function(cue) {\n                    // avoid duplicates\n                    if (cueSet.has(cue.key)) {\n                        return;\n                    } else {\n                        cueSet.add(cue.key);\n                    }\n                    result.push(cue);\n                });\n        }\n        return result;\n    }\n\n\n\n    /*\n        LOOKUP\n\n        Strategy split task into two subtasks,\n\n        1) find cues [OVERLAP_LEFT, COVERED, EQUALS, OVERLAP_RIGHT]\n        2) find cues [COVERS]\n\n        // mode order\n        Relation.OVERLAP_LEFT,\n        Relation.COVERED,\n        Relation.EQUALS,\n        Relation.COVERS,\n        Relation.OVERLAP_RIGHT\n    */\n\n\n    lookup(interval, mask=Interval.Match.COVERS) {\n\n        let cues = [];\n\n        // ignore illegal values\n        mask &= Interval.Match.COVERS;\n\n        // special case only [EQUALS]\n        if (mask == Relation.EQUALS) {\n            return this._pointMap.get(interval.low).filter(function(cue) {\n                return cue.interval.match(interval, Relation.EQUALS);\n            });\n        }\n\n        // handle match with the basic lookup mask first\n        // [OVERLAP_LEFT, COVERED, EQUALS, OVERLAP_RIGHT]\n        let _mask = mask & Interval.Match.OVERLAP;\n        if (_mask) {\n            // keep cues which match lookup part of basic mask,\n            cues = this._lookup_cues(interval)\n                .filter(function(cue){\n                    return cue.interval.match(interval, _mask);\n                });\n        }\n\n        /*\n            intervals in this CueBucket are limited by maxLength\n            if interval.length is larger than maxLength, no cue\n            in this CueBucket can cover interval\n        */\n        if (interval.length > this._maxLength) {\n            return cues;\n        }\n\n        /*\n            handle match with COVERS separately\n\n            search left of search interval for cues\n            that covers the search interval\n            search left is limited by CueBucket maxlength\n            left_interval: [interval.high-maxLength, interval.low]\n\n            it would be possible to search right too, but we\n            have to choose one.\n        */\n        if (mask & Relation.COVERS) {\n            let low = interval.high - this._maxLength;\n            let high = interval.low;\n            let left_interval = new Interval(low, high, true, true);\n            this._lookup_cues(left_interval)\n                .forEach(function(cue){\n                    if (cue.interval.match(interval, Relation.COVERS)) {\n                        cues.push(cue);\n                    }\n                });\n        }\n\n        return cues;\n    }\n\n\n    /*\n        REMOVE CUES\n    */\n    lookup_delete(interval, mask) {\n        /*\n            update pointMap\n            - remove all cues from pointMap\n            - remove empty entries in pointMap\n            - record points that became empty, as these need to be deleted in pointIndex\n            - separate into two bucketes, inside and outside\n        */\n        const cues = this.lookup(interval, mask);\n        const to_remove = [];\n        let cue, point, points;\n        for (let i=0; i<cues.length; i++) {\n            cue = cues[i];\n            // points of cue\n            if (cue.interval.singular) {\n                points = [cue.interval.low];\n            } else {\n                points = [cue.interval.low, cue.interval.high];\n            }\n            for (let j=0; j<points.length; j++) {\n                point = points[j];\n                // remove cue from pointMap\n                // delete pointMap entry only if empty\n                let empty = removeCueFromArray(this._pointMap.get(point), cue);\n                if (empty) {\n                    this._pointMap.delete(point);\n                    to_remove.push(point);\n                }\n            }\n        }\n\n        /*\n            update pointIndex\n\n            - remove all points within pointIndex\n            - exploit locality, the operation is limited to a segment of the index, so\n              the basic idea is to take out a copy of segment (slice), do modifications, and then reinsert (splice)\n            - the segment to modify is limited by [interval.low - maxLength, interval.high + maxLenght] as this will cover\n              both cues inside, partial and overlapping.\n\n            # Possible - optimization\n            alternative approach using regular update could be more efficient for very samll batches\n            this._pointIndex.update(to_remove, []);\n            it could also be comparable for huge loads (250.000 cues)\n        */\n\n        to_remove.sort(function(a,b){return a-b});\n        this._pointIndex.removeInSlice(to_remove);\n\n        /*\n            alternative solution\n            this._pointIndex.update(to_remove, []);\n        */\n\n        return cues;\n    };\n\n\n    /*\n        Possible optimization. Implement a removecues method that\n        exploits locality by removing an entire slice of pointIndex.\n        - this can safely be done for LookupMethod.OVERLAP and PARTIAL.\n        - however, for LookupMethod.INSIDE, which is likely the most useful\n          only some of the points in pointIndex shall be removed\n          solution could be to remove entire slice, construct a new slice\n          with those points that should not be deleted, and set it back in.\n    */\n    clear() {\n        this._pointMap.clear();\n        this._pointIndex = new BinarySearch();\n        this._created.clear();\n        this._dirty.clear();\n    };\n\n\n    /*\n        Integrity test for cue bucket datastructures\n        pointMap and pointIndex\n    */\n    integrity() {\n\n        if (this._pointMap.size !== this._pointIndex.length) {\n            throw new Error(\"unequal number of points \" + (this._pointMap.size - this._pointIndex.length));\n        }\n\n        // check that the same cues are present in both pointMap and pointIndex\n        const missing = new Set();\n        for (let point of this._pointIndex.values()) {\n            if (!this._pointMap.has(point)){\n                missing.add(point);\n            }\n        }\n        if (missing.size > 0) {\n            throw new Error(\"differences in points \" + [...missing]);\n        }\n\n        // collect all cues\n        let cues = [];\n        for (let _cues of this._pointMap.values()) {\n            for (let cue of _cues.values()) {\n                cues.push(cue);\n            }\n        }\n        // remove duplicates\n        cues = [...new Map(cues.map(function(cue){\n            return [cue.key, cue];\n        })).values()];\n\n        // check all cues\n        for (let cue of cues.values()) {\n            if (cue.interval.length > this._maxLength) {\n                throw new Error(\"cue interval violates maxLength \",  cue);\n            }\n            let points;\n            if (cue.singular) {\n                points = [cue.interval.low];\n            } else {\n                points = [cue.interval.low, cue.interval.high];\n            }\n            for (let point of points.values()) {\n                if (!this._pointIndex.has(point)) {\n                    throw new Error(\"point from pointMap cue not found in pointIndex \", point);\n                }\n            }\n        }\n\n        return [{\n            maxLength: this._maxLength,\n            points: [...this._pointMap.keys()],\n            cues: cues\n        }];\n    };\n}\n\n// module definition\nexport default Dataset;\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nimport endpoint from '../util/endpoint.js';\nimport Interval from '../util/interval.js';\nimport Timeout from '../util/timeout.js';\nimport * as motionutils from '../util/motionutils.js';\n\nconst pft = motionutils.posInterval_from_timeInterval;\n\nfunction queueCmp(a,b) {\n    return endpoint.cmp(a.tsEndpoint, b.tsEndpoint);\n};\n\nclass Schedule {\n\n    // Default lookahead in seconds\n    static LOOKAHEAD = 5\n\n    constructor(axis, to, options) {\n        // timingobject\n        this.to = to;\n        // current timeout\n        this.timeout = new Timeout(to, this.run.bind(this));\n        // current vector\n        this.vector;\n        // current time interval\n        this.timeInterval;\n        // current position interval\n        this.posInterval;\n        // axis\n        this.axis = axis;\n        // task queue\n        this.queue = [];\n        // callbacks\n        this.callbacks = [];\n        // options\n        options = options || {};\n        options.lookahead = options.lookahead || Schedule.LOOKAHEAD;\n        this.options = options;\n    }\n\n\n    /***************************************************************\n        CALLBACKS\n    ***************************************************************/\n\n    add_callback (handler) {\n        let handle = {\n            handler: handler\n        }\n        this.callbacks.push(handle);\n        return handle;\n    };\n\n    del_callback (handle) {\n        let index = this.callbacks.indexof(handle);\n        if (index > -1) {\n            this.callbacks.splice(index, 1);\n        }\n    };\n\n    _notify_callbacks (...args) {\n        this.callbacks.forEach(function(handle) {\n            handle.handler(...args);\n        });\n    };\n\n    /***************************************************************\n        MOTION CHANGE\n    ***************************************************************/\n\n    /*\n        update schedule with new motion vector\n    */\n    setVector(vector) {\n        let now = vector.timestamp;\n        // clean up current motion\n        let current_vector = this.vector;\n        if (this.vector != undefined) {\n            this.timeout.clear();\n            this.timeInterval = undefined;\n            this.posInterval = undefined;\n            this.queue = [];\n        }\n        // update vector\n        this.vector = vector;\n        // start scheduler if moving\n        if (motionutils.isMoving(this.vector)) {\n            this.run(now);\n        }\n    }\n\n\n    /***************************************************************\n        TASK QUEUE\n    ***************************************************************/\n\n    /*\n        push eventItem onto queue\n    */\n    push(eventItems) {\n        eventItems.forEach(function(item) {\n            if (this.timeInterval.covers_endpoint(item.tsEndpoint)) {\n                this.queue.push(item);\n            }\n        }, this);\n        // maintain ordering\n        this.queue.sort(queueCmp);\n    };\n\n    /*\n        pop due eventItems from queue\n    */\n    pop(now) {\n        let eventItem, res = [];\n        let len = this.queue.length;\n        while (this.queue.length > 0 && this.queue[0].tsEndpoint[0] <= now) {\n            res.push(this.queue.shift());\n        }\n        return res;\n    };\n\n    /*\n        return timestamp of next eventItem\n    */\n    next() {\n        return (this.queue.length > 0) ? this.queue[0].tsEndpoint[0]: undefined;\n    }\n\n\n    /***************************************************************\n        ADVANCE TIMEINTERVAL/POSINTERVAL\n    ***************************************************************/\n\n\n    /*\n        advance timeInterval and posInterval if needed\n    */\n    advance(now) {\n        let start, delta = this.options.lookahead;\n        let advance = false;\n        if (this.timeInterval == undefined) {\n            start = now;\n            advance = true;\n        } else if (endpoint.leftof(this.timeInterval.endpointHigh, now)) {\n            start = this.timeInterval.high;\n            advance = true\n        }\n        if (advance) {\n            // advance intervals\n            this.timeInterval = new Interval(start, start + delta, true, false);\n            this.posInterval = pft(this.timeInterval, this.vector);\n            // clear task queue\n            this.queue = [];\n        }\n        return advance;\n    }\n\n\n    /***************************************************************\n        LOAD\n    ***************************************************************/\n\n    /*\n        load events\n    */\n\n    load(endpoints, minimum_tsEndpoint) {\n        let endpointEvents = motionutils.endpointEvents(this.timeInterval,\n                                                        this.posInterval,\n                                                        this.vector,\n                                                        endpoints);\n\n        /*\n            ISSUE 1\n\n            Range violation might occur within timeInterval.\n            All endpointEvents with .tsEndpoint later or equal to range\n            violation will be cancelled.\n        */\n        let range_ts = motionutils.rangeIntersect(this.vector, this.to.range)[0];\n\n        /*\n            ISSUE 2\n\n            If load is used in response to dynamically added cues, the\n            invocation of load might occor at any time during the timeInterval,\n            as opposed to immediately after the start of timeInterval.\n            This again implies that some of the endPointEvents we have found\n            from the entire timeInterval might already be historic at time of\n            invocation.\n\n            Cancel endpointEvents with .tsEndpoint < minimum_ts.\n\n            For regular loads this will have no effect since we\n            do not specify a minimum_ts, but instead let it assume the\n            default value of timeInterval.low.\n        */\n        if (minimum_tsEndpoint == undefined) {\n            minimum_tsEndpoint = this.timeInterval.endpointLow;\n        }\n\n        /*\n            ISSUE 3\n\n            With acceleration the motion might change direction at\n            some point, which might also be a cue endpoint. In this\n            case, motion touches the cue endpoint but does not actually\n            cross over it.\n\n            For simplicity we say that this should not change the\n            active state of that cue. The cue is either not activated\n            or not inactivated by this occurrence. We might therefor\n            simply drop such endpointEvents.\n\n            To detect this, note that velocity will be exactly 0\n            evaluated at the cue endpoint, but acceleration will be nonzero.\n\n            Importantly, there is one exception. Dropping such events\n            should only happen when 0 velocity is reached during motion,\n            not at the start of a motion. For instance, in the case of\n            starting with acceleration but no velocity, from a cue\n            endpoint, this event should not be dropped.\n            This is avoided by requiring that the tsEndpoint is not\n            equal to timeInterval.endpointLow\n\n        */\n\n        return endpointEvents.filter(function(item) {\n            // ISSUE 1\n            if (range_ts <= item.tsEndpoint[0]) {\n                // console.log(\"issue1\");\n                return false;\n            }\n\n            // ISSUE 2\n            if (endpoint.leftof(item.tsEndpoint, minimum_tsEndpoint)) {\n                // console.log(\"issue2\");\n                return false;\n            }\n            // ISSUE 3\n            // checks every event. alternative approach would be\n            // to calculate the ts of this event once, and compare\n            // the result to the ts of all event\n            if (this.vector.acceleration != 0.0) {\n                let ts = item.tsEndpoint[0];\n                if (ts > this.timeInterval.endpointLow[0]) {\n                    let v = motionutils.calculateVector(this.vector, ts);\n                    if (v.position == item.endpoint[0] && v.velocity == 0) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }, this);\n    }\n\n\n    /***************************************************************\n        RUN\n    ***************************************************************/\n\n    /*\n        run schedule\n    */\n    run(now) {\n        // process - due events\n        let dueEvents = this.pop(now);\n        // advance schedule and load events if needed\n        if (this.advance(now)) {\n            // fetch cue endpoints for posInterval\n            let endpointItems = this.axis.lookup_endpoints(this.posInterval);\n            // load events and push on queue\n            this.push(this.load(endpointItems));\n            // process - possibly new due events\n            dueEvents.push(...this.pop(now));\n        }\n        if (dueEvents.length > 0) {\n            this._notify_callbacks(now, dueEvents, this);\n        }\n        // timeout - until next due event\n        let ts = this.next() || this.timeInterval.high;\n        this.timeout.setTimeout(Math.min(ts, this.timeInterval.high));\n    }\n}\n\nexport default Schedule;\n\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport {map_intersect, map_difference} from '../util/utils.js';\nimport Interval from '../util/interval.js';\nimport eventify from '../util/eventify.js';\nimport Dataset from './dataset.js';\n\n\nfunction isNoop(delta) {\n    return (delta.interval == Dataset.Delta.NOOP && delta.data == Dataset.Delta.NOOP);\n}\n\n\n/*******************************************************************\n ACTIVE MAP\n*******************************************************************/\n/*\n\n    This table describes cue changes to/from active state\n    based on\n\n    - to_role - the role of the timing object\n\n      in the case of the double sequencer a timing object\n      may be *LEFT* (L), *RIGHT* (R) or, in the corner case that\n      the two timing objects are at the same position,\n      *SINGULAR* (S)\n\n      in the case of the single sequencer, the role is\n      always *SINGULAR* (S)\n\n\n    - to_direction - the direction of the movement of the\n      timing object, either *RIGHT* (R) or *LEFT* (L)\n\n      This map is only used when timing object is in a\n      moving state, so *PAUSED* (P) is not needed.\n\n    - endpoint_type - the type of endpoint which is\n      passed by the timing object during motion, either\n      *LEFT* (R) endpoint or *RIGHT* (R) endpoint, or\n      *SINGULAR* (S) endpoint.\n\n    - cue_change\n      *ENTER* : cue changes from not active to active\n      *EXIT*: cue changes from active to not active\n      *STAY*: cue stays active\n      *ENTER-EXIT*: cue changes from not active to active,\n                    and immediately back agoind to not active\n                    This only occurs when a *SINGULAR*\n                    timing object passed a *SINGULAR* cue.\n\n\n    Table columns are:\n\n    | to_role | to_direction | endpoint_type | cue change |\n\n    left, right, left -> stay\n    left, right, right -> exit\n    left, right, singular -> exit\n\n    left, left, left -> stay\n    left, left, right -> enter\n    left, left, singular -> enter\n\n    right, right, left -> enter\n    right, right, right -> stay\n    right, right, singular -> enter\n\n    right, left, left -> exit\n    right, left, right -> stay\n    right, left, singular -> exit\n\n    // cornercase - timing objects are the same\n\n    singular, right, left -> enter\n    singular, right, right -> exit\n    singular, right, singular -> enter, exit\n\n    singular, left, left -> exit\n    singular, left, right -> enter\n    singular, left, singular -> enter, exit\n\n*/\n\nconst Active = Object.freeze({\n    ENTER: 1,\n    STAY: 0,\n    EXIT: -1,\n    ENTER_EXIT: 2\n});\n\nconst ActiveMap = new Map([\n    [\"LRL\", Active.STAY],\n    [\"LRR\", Active.EXIT],\n    [\"LRS\", Active.EXIT],\n    [\"LLL\", Active.STAY],\n    [\"LLR\", Active.ENTER],\n    [\"LLS\", Active.ENTER],\n    [\"RRL\", Active.ENTER],\n    [\"RRR\", Active.STAY],\n    [\"RRS\", Active.ENTER],\n    [\"RLL\", Active.EXIT],\n    [\"RLR\", Active.STAY],\n    [\"RLS\", Active.EXIT],\n    [\"SRL\", Active.ENTER],\n    [\"SRR\", Active.EXIT],\n    [\"SRS\", Active.ENTER_EXIT],\n    [\"SLL\", Active.EXIT],\n    [\"SLR\", Active.ENTER],\n    [\"SLS\", Active.ENTER_EXIT]\n]);\n\n\n\n/*******************************************************************\n EVENT ORDERING SORTING\n*******************************************************************/\n\nfunction event_cmp_forwards (event_a, event_b) {\n    let itv_a = (event_a.new) ? event_a.new.interval : event_a.old.interval;\n    let itv_b = (event_b.new) ? event_b.new.interval : event_b.old.interval;\n    return Interval.cmpLow(itv_a, itv_b);\n}\n\nfunction event_cmp_backwards (event_a, event_b) {\n    let itv_a = (event_a.new) ? event_a.new.interval : event_a.old.interval;\n    let itv_b = (event_b.new) ? event_b.new.interval : event_b.old.interval;\n    return -1 * Interval.cmpHigh(itv_a, itv_b);\n}\n\nfunction sort_events (events, direction=0) {\n    if (direction >= 0) {\n        events.sort(event_cmp_forwards);\n    } else {\n        events.sort(event_cmp_backwards);\n    }\n}\n\n\n/*******************************************************************\n BASE SEQUENCER\n*******************************************************************/\n\n/*\n    This is an abstract base class for sequencers\n    It implements common logic related to Dataset, events and activeCues.\n*/\n\nclass BaseSequencer {\n\n    static Active = Active;\n    static ActiveMap = ActiveMap;\n    static sort_events = sort_events;\n\n    constructor (dataset) {\n\n        // ActiveCues\n        this._activeCues = new Map(); // (key -> cue)\n\n        // Dataset\n        this._ds = dataset;\n        let cb = this._onDatasetCallback.bind(this)\n        this._ds_cb = this._ds.add_callback(cb);\n\n        // Change event\n        eventify.eventifyInstance(this);\n        this.eventifyDefine(\"update\", {init:true});\n        this.eventifyDefine(\"change\", {init:true});\n        this.eventifyDefine(\"remove\", {init:false});\n    }\n\n\n    get_movement_direction() {\n        throw new Error(\"not implemented\");\n    }\n\n\n    /***************************************************************\n     EVENTS\n    ***************************************************************/\n\n    /*\n        Eventify: immediate events\n    */\n    eventifyInitEventArgs(name) {\n        if (name == \"update\" || name == \"change\") {\n            let events = [...this._activeCues.values()].map(cue => {\n                return {key:cue.key, new:cue, old:undefined};\n            });\n            sort_events(events, this.get_movement_direction());\n            return (name == \"update\") ? [events] : events;\n        }\n    }\n\n\n    /*\n        Event Notification\n\n    */\n    _notifyEvents(events) {\n        // event notification\n        if (events.length == 0) {\n            return;\n        }\n        const has_update_subs = this.eventifySubscriptions(\"update\").length > 0;\n        const has_remove_subs = this.eventifySubscriptions(\"remove\").length > 0;\n        const has_change_subs = this.eventifySubscriptions(\"change\").length > 0;\n        // update\n        if (has_update_subs) {\n            this.eventifyTrigger(\"update\", events);\n        }\n        // change, remove\n        if (has_remove_subs || has_change_subs) {\n            for (let item of events) {\n                if (item.new == undefined) {\n                    if (has_remove_subs) {\n                        this.eventifyTrigger(\"remove\", item);\n                    }\n                } else {\n                    if (has_change_subs) {\n                        this.eventifyTrigger(\"change\", item);\n                    }\n                }\n            }\n        }\n    }\n\n\n    /***************************************************************\n     DATASET\n    ***************************************************************/\n\n    get ds () { return this._ds;}\n\n    _onDatasetCallback(eventMap, relevanceInterval) {\n        throw new Error(\"not implemented\");\n    }\n\n    /*\n        make exit, change and enter events\n        - based on eventMap\n    */\n    _events_from_dataset_events(eventMap, interval) {\n        const enterEvents = [];\n        const changeEvents = [];\n        const exitEvents = [];\n        const first = this._activeCues.size == 0;\n        let is_active, should_be_active, _item;\n        for (let item of eventMap.values()) {\n            if (isNoop(item.delta)) {\n                continue;\n            }\n            // exit, change, enter events\n            is_active = (first) ? false : this._activeCues.has(item.key);\n            should_be_active = false;\n            if (item.new != undefined) {\n                if (item.new.interval.match(interval)) {\n                    should_be_active = true;\n                }\n            }\n            if (is_active && !should_be_active) {\n                // exit\n                _item = {key:item.key, new:undefined, old:item.old};\n                exitEvents.push(_item);\n            } else if (!is_active && should_be_active) {\n                // enter\n                _item = {key:item.key, new:item.new, old:undefined};\n                enterEvents.push(_item);\n            } else if (is_active && should_be_active) {\n                // change\n                _item = {key:item.key, new:item.new, old:item.old};\n                changeEvents.push(_item);\n            }\n        };\n        return [exitEvents, changeEvents, enterEvents];\n    }\n\n    /*\n        make exit, change and enter events\n        - based on dataset.lookup\n    */\n    _events_from_dataset_lookup(eventMap, interval) {\n\n        /*\n            Active cues\n\n            find new set of active cues by querying the dataset\n        */\n        const _activeCues = new Map(this._ds.lookup(interval).map(function(cue) {\n            return [cue.key, cue];\n        }));\n\n        let changeEvents = [];\n        let exitEvents = [];\n        let first = (this._activeCues.size == 0);\n        if (!first){\n\n            /*\n                Change Events\n\n                change cues - cues which are modified, yet remain active cues\n            */\n            let remainCues = map_intersect(this._activeCues, _activeCues);\n            if (remainCues.size > 0) {\n                /*\n                    Two approaches\n\n                    1) large eventMap\n                    eventMap larger than remainCues\n                    - iterate remainCues\n                    - keep those that are found in eventMap\n\n                    2) large remainCues\n                    remainCues larger than eventMap\n                    - iterate eventMap\n                    - keep those that are found in remainCues\n\n                    measurement shows that 2) is better\n                */\n                let cue, _item;\n                for (let item of eventMap.values()) {\n                    cue = remainCues.get(item.key);\n                    if (cue != undefined && !isNoop(item.delta)) {\n                        _item = {key:item.key, new:item.new, old:item.old};\n                        changeEvents.push(_item);\n                    }\n                }\n            }\n\n            /*\n                Exit Events\n                exit cues were in old active cues - but not in new\n            */\n            let exitCues = map_difference(this._activeCues, _activeCues);\n            exitEvents = [...exitCues.values()]\n                .map(cue => {\n                    return {key:cue.key, new:undefined, old:cue};\n                });\n        }\n\n        /*\n            Enter Events\n            enter cues were not in old active cues - but are in new\n        */\n        let enterCues;\n        if (first) {\n            enterCues = _activeCues\n        } else {\n            enterCues = map_difference(_activeCues, this._activeCues);\n        }\n        let enterEvents = [...enterCues.values()]\n            .map(cue => {\n                return {key:cue.key, new:cue, old:undefined};\n            });\n\n        return [exitEvents, changeEvents, enterEvents];\n    }\n\n\n    /***************************************************************\n     MAP ACCESSORS\n    ***************************************************************/\n\n    has(key) {\n        return this._activeCues.has(key);\n    };\n\n    get(key) {\n        return this._activeCues.get(key);\n    };\n\n    keys() {\n        return this._activeCues.keys();\n    };\n\n    values() {\n        return this._activeCues.values();\n    };\n\n    entries() {\n        return this._activeCues.entries();\n    }\n}\n\neventify.eventifyPrototype(BaseSequencer.prototype);\n\nexport default BaseSequencer;\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport {array_concat, map_difference} from '../util/utils.js';\nimport Interval from '../util/interval.js';\nimport eventify from '../util/eventify.js';\nimport * as motionutils from '../util/motionutils.js';\nimport Schedule from './schedule.js';\nimport BaseSequencer from './basesequencer.js';\nimport Dataset from './dataset.js';\n\nconst PosDelta = motionutils.MotionDelta.PosDelta;\nconst MoveDelta = motionutils.MotionDelta.MoveDelta;\nconst Active = BaseSequencer.Active;\nconst ActiveMap = BaseSequencer.ActiveMap;\nconst Relation = Interval.Relation;\n\nconst EVENTMAP_THRESHOLD = 5000;\nconst ACTIVECUES_THRESHOLD = 5000;\n\n\nclass SingleSequencer extends BaseSequencer {\n\n    constructor (dataset, to) {\n\n        super(dataset);\n\n        // Timing Object\n        this._to = to;\n        this._sub = this._to.on(\"timingsrc\", this._onTimingCallback.bind(this));\n\n        // Schedule\n        this._sched = new Schedule(this._ds, to);\n        let cb = this._onScheduleCallback.bind(this);\n        this._sched_cb = this._sched.add_callback(cb)\n    }\n\n\n    get_movement_direction() {\n        const now = this._to.clock.now();\n        return motionutils.calculateDirection(this._to.vector, now);\n    }\n\n\n    /***************************************************************\n     DATASET CALLBACK\n    ***************************************************************/\n\n    /*\n        Handling Dataset Update Callbacks\n    */\n\n    _onDatasetCallback(eventMap, relevanceInterval) {\n        /*\n            process dataset events which are relevant to the set\n            of activeCues, or to the immediate future (schedule)\n\n            enterCues - inactive -> active\n            changeCues - active -> active, but changed\n            exitCues - active -> inactive\n\n            Two approaches\n            - 1) EVENTS: filter list of events - compare to current active cues\n            - 2) LOOKUP: regenerate new activeCues by looking up set of\n                 active cues from dataset, compare it to current active cues\n\n\n            EventMap.size < about 1K-10K (5K)\n            - EVENTS better or equal\n            EventMap.size > about 5K\n            - LOOKUP better\n            - exception\n                - If activeCues.size > 1K-10K (5K) - EVENTS BETTER\n\n            If new cues are predominantly active cues, EVENTS are\n            always better - and more so for larger sets of events.\n            However, there is no information about this\n            before making the choice, and also this is a somewhat\n            unlikely scenario.\n\n            So, the simple policy above works for typical workloads,\n            where the majority of added cues are inactive.\n        */\n\n        if (!this._to.isReady()) {\n            return;\n        }\n\n        if (relevanceInterval == undefined) {\n            return;\n        }\n\n        const now = this._to.clock.now();\n        const now_vector = motionutils.calculateVector(this._to.vector, now);\n\n        // activeInterval\n        const activeInterval = new Interval(now_vector.position);\n\n        if (!activeInterval.match(relevanceInterval, Interval.Match.OUTSIDE)) {\n            // relevanceInterval is NOT outside activeInterval\n            // some events relevant for activeIntervale\n\n            // choose approach to get events\n            let get_events = this._events_from_dataset_events.bind(this);\n            if (EVENTMAP_THRESHOLD < eventMap.size) {\n                if (this._activeCues.size < ACTIVECUES_THRESHOLD) {\n                    get_events = this._events_from_dataset_lookup.bind(this);\n                }\n            }\n\n            // get events\n            const [exit, change, enter] = get_events(eventMap, activeInterval);\n\n            // update activeCues\n            exit.forEach(item => {\n                this._activeCues.delete(item.key);\n            });\n            enter.forEach(item => {\n                this._activeCues.set(item.key, item.new);\n            });\n\n            // notifications\n            const events = array_concat([exit, change, enter], {copy:true, order:true});\n\n            // sort events according to general movement direction\n            let direction = motionutils.calculateDirection(now_vector);\n            BaseSequencer.sort_events(events, direction);\n\n            // event notification\n            this._notifyEvents(events);\n        }\n\n        /*\n            clear schedule\n\n            This is only necessary if a cue interval is changed,\n            and the change is relevant within the posInterval of\n            of the schedule. RelevanceInterval to figure this out.\n        */\n        if (this._sched.posInterval) {\n            if (!this._sched.posInterval.match(relevanceInterval, Interval.Match.OUTSIDE)) {\n                // relevanceInterval is NOT outside schedule posInterval\n                // refresh schedule\n                this._sched.setVector(now_vector);\n            }\n        }\n    }\n\n\n    /***************************************************************\n     TIMING OBJECT CALLBACK\n    ***************************************************************/\n\n    _onTimingCallback (eArg) {\n        const events = [];\n        /*\n            If update is the initial vector from the timing object,\n            we set current time as the official time for the update.\n            Else, the new vector is \"live\" and we use the timestamp\n            when it was created as the official time for the update.\n            This is represented by the new_vector.\n        */\n        let new_vector;\n\n        if (eArg.live) {\n            new_vector = this._to.vector;\n        } else {\n            // make a live vector from to vector\n            new_vector = motionutils.calculateVector(this._to.vector, this._to.clock.now());\n        }\n\n        /*\n            The nature of the vector change\n        */\n        let delta = new motionutils.MotionDelta(this._to.old_vector, new_vector);\n\n        /*\n            Reevaluate active state.\n            This is required after any discontinuity of the position (jump),\n            or if the motion stopped without jumping (pause or halt at range\n            restriction)\n        */\n        if (delta.posDelta == PosDelta.CHANGE || delta.moveDelta == MoveDelta.STOP) {\n            // make position interval\n            let low = new_vector.position;\n            let high = new_vector.position;\n            let itv = new Interval(low, high, true, true);\n            // new active cues\n            let activeCues = new Map(this._ds.lookup(itv).map(cue => {\n                return [cue.key, cue];\n            }));\n            // exit cues - in old activeCues but not in new activeCues\n            let exitCues = map_difference(this._activeCues, activeCues);\n            // enter cues - not in old activeCues but in new activeCues\n            let enterCues = map_difference(activeCues, this._activeCues);\n            // update active cues\n            this._activeCues = activeCues;\n            // make events\n            for (let cue of exitCues.values()) {\n                events.push({key:cue.key, new:undefined, old:cue});\n            }\n            for (let cue of enterCues.values()) {\n                events.push({key:cue.key, new:cue, old:undefined});\n            }\n\n            // sort events according to general movement direction\n            let direction = motionutils.calculateDirection(new_vector);\n            BaseSequencer.sort_events(events, direction);\n\n            // event notification\n            this._notifyEvents(events);\n        }\n\n        /*\n            Handle Timing Object Moving\n        */\n        this._sched.setVector(new_vector);\n    };\n\n\n    /***************************************************************\n     SCHEDULE CALLBACK\n    ***************************************************************/\n\n    _onScheduleCallback = function(now, endpointItems, schedule) {\n        if (!this._to.isReady()) {\n            return;\n        }\n\n        const events = [];\n        endpointItems.forEach(function (item) {\n            let cue = item.cue;\n            let has_cue = this._activeCues.has(cue.key);\n            let [value, right, closed, singular] = item.endpoint;\n\n            /*\n                Action Code - see sequenceutils\n            */\n            // to role\n            let to_role = \"S\";\n            // movement direction\n            let to_dir = (item.direction > 0) ? \"R\" : \"L\";\n            // endpoint type\n            let ep_type = (singular) ? \"S\": (right) ? \"R\" : \"L\";\n            // action code, enter, exit, stay, enter-exit\n            let action_code = ActiveMap.get(`${to_role}${to_dir}${ep_type}`);\n\n            if (action_code == Active.ENTER_EXIT) {\n                if (has_cue) {\n                    // exit\n                    events.push({key:cue.key, new:undefined, old:cue});\n                    this._activeCues.delete(cue.key);\n                } else {\n                    // enter\n                    events.push({key:cue.key, new:cue, old:undefined});\n                    // exit\n                    events.push({key:cue.key, new:undefined, old:cue});\n                    // no need to both add and remove from activeCues\n                }\n            } else if (action_code == Active.ENTER) {\n                if (!has_cue) {\n                    // enter\n                    events.push({key:cue.key, new:cue, old:undefined});\n                    this._activeCues.set(cue.key, cue);\n                }\n            } else if (action_code == Active.EXIT) {\n                if (has_cue) {\n                    // exit\n                    events.push({key:cue.key, new:undefined, old:cue});\n                    this._activeCues.delete(cue.key);\n                }\n            }\n        }, this);\n\n        // Events already sorted\n\n        // event notification\n        this._notifyEvents(events);\n    };\n}\n\nexport default SingleSequencer;\n\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport {array_concat, map_difference} from '../util/utils.js';\nimport Interval from '../util/interval.js';\nimport eventify from '../util/eventify.js';\nimport * as motionutils from '../util/motionutils.js';\nimport Schedule from './schedule.js';\nimport BaseSequencer from './basesequencer.js';\nimport dataset from './dataset.js';\n\nconst PosDelta = motionutils.MotionDelta.PosDelta;\nconst MoveDelta = motionutils.MotionDelta.MoveDelta;\nconst Active = BaseSequencer.Active;\nconst ActiveMap = BaseSequencer.ActiveMap;\nconst Relation = Interval.Relation;\n\nconst EVENTMAP_THRESHOLD = 5000;\nconst ACTIVECUES_THRESHOLD = 5000;\n\n/*\n    calculate general movement direction for double sequencer\n    define movement direction as the aggregate movement direction\n    for both timing objects\n*/\nfunction movement_direction (now_vector_A, now_vector_B) {\n    let direction_A = motionutils.calculateDirection(now_vector_A);\n    let direction_B = motionutils.calculateDirection(now_vector_B);\n    let direction = direction_A + direction_B;\n    return (direction > 0) ? 1 : (direction < 0) ? -1 : 0;\n}\n\n\nclass DoubleSequencer extends BaseSequencer {\n\n    constructor (dataset, toA, toB) {\n\n        super(dataset);\n\n        // Timing objects\n        this._toA = toA;\n        this._toA_ready = false;\n        this._toB = toB;\n        this._toB_ready = false;\n        let to_cb = this._onTimingCallback.bind(this);\n        this._subA = this._toA.on(\"timingsrc\", to_cb);\n        this._subB = this._toB.on(\"timingsrc\", to_cb);\n\n        // Schedules\n        let sched_cb = this._onScheduleCallback.bind(this);\n        this._schedA = new Schedule(this._ds, toA);\n        this._schedA_cb = this._schedA.add_callback(sched_cb);\n        this._schedB = new Schedule(this._ds, toB);\n        this._schedB_cb = this._schedB.add_callback(sched_cb);\n\n    }\n\n\n    _isReady() {\n        return (this._toA_ready && this._toB_ready);\n    }\n\n    get_movement_direction() {\n        const now = this._toA.clock.now();\n        const now_vector_A = motionutils.calculateVector(this._toA.vector, now);\n        const now_vector_B = motionutils.calculateVector(this._toB.vector, now);\n        return movement_direction(now_vector_A, now_vector_B);\n    }\n\n    /***************************************************************\n     DATASET CALLBACK\n    ***************************************************************/\n\n    /*\n        Handling Dataset Update Callbacks\n    */\n    _onDatasetCallback(eventMap, relevanceInterval) {\n        if (!this._isReady()) {\n            return;\n        }\n\n        if (relevanceInterval == undefined) {\n            return;\n        }\n\n        // assuming both timing objects have the same clock\n        const now = this._toA.clock.now();\n        const now_vector_A = motionutils.calculateVector(this._toA.vector, now);\n        const now_vector_B = motionutils.calculateVector(this._toB.vector, now);\n\n        // active interval\n        let [pos_A, pos_B] = [now_vector_A.position, now_vector_B.position];\n        let [low, high] = (pos_A <= pos_B) ? [pos_A, pos_B] : [pos_B, pos_A];\n        const activeInterval = new Interval(low, high, true, true);\n\n        if (!activeInterval.match(relevanceInterval, Interval.Match.OUTSIDE)) {\n            // relevanceInterval is NOT outside activeInterval\n            // some events relevant for activeIntervale\n\n            // choose approach to get events\n            let get_events = this._events_from_dataset_events.bind(this);\n            if (EVENTMAP_THRESHOLD < eventMap.size) {\n                if (this._activeCues.size < ACTIVECUES_THRESHOLD) {\n                    get_events = this._events_from_dataset_lookup.bind(this);\n                }\n            }\n\n            // get events\n            const [exit, change, enter] = get_events(eventMap, activeInterval);\n\n            // update activeCues\n            exit.forEach(item => {\n                this._activeCues.delete(item.key);\n            });\n            enter.forEach(item => {\n                this._activeCues.set(item.key, item.new);\n            });\n\n            // notifications\n            const events = array_concat([exit, change, enter], {copy:true, order:true});\n\n            // sort events according to general movement direction\n            let direction = movement_direction(now_vector_A, now_vector_B);\n            BaseSequencer.sort_events(events, direction);\n\n            // event notification\n            this._notifyEvents(events, direction);\n        }\n\n\n        /*\n            clear schedules\n\n            This is only necessary if a cue interval is changed,\n            and the change is relevant within the posInterval of\n            one of the schedules. RelevanceInterval to figure this out.\n        */\n\n        if (this._schedA.posInterval) {\n            if (!this._schedA.posInterval.match(relevanceInterval, Interval.Match.OUTSIDE)) {\n                // relevanceInterval is NOT outside schedule posInterval\n                // refresh schedule\n                this._schedA.setVector(now_vector_A);\n            }\n        }\n\n        if (this._schedB.posInterval) {\n            if (!this._schedB.posInterval.match(relevanceInterval, Interval.Match.OUTSIDE)) {\n                // relevanceInterval is NOT outside schedule posInterval\n                // refresh schedule\n                this._schedB.setVector(now_vector_B);\n            }\n        }\n    }\n\n\n    /***************************************************************\n     TIMING OBJECT CALLBACK\n    ***************************************************************/\n\n    /*\n        Handling Change Events from Timing Objects\n    */\n    _onTimingCallback (eArg, eInfo) {\n\n        /*\n            make sure both timingobjects are ready\n        */\n        let init = false;\n        if (!this._isReady()) {\n            if (eInfo.src == this._toA) {\n                this._toA_ready = true;\n            } else {\n                this._toB_ready = true;\n            }\n            if (this._isReady()) {\n                init = true;\n            } else {\n                return;\n            }\n        }\n\n        /*\n            figure out which timing object was firing\n        */\n        const to = eInfo.src;\n        const other_to = (to == this._toA) ? this._toB : this._toA;\n\n        /*\n            If update is the initial vector from the timing object,\n            we set current time as the official time for the update.\n            Else, the new vector is \"live\" and we use the timestamp\n            when it was created as the official time for the update.\n            This is represented by the new_vector.\n        */\n        let new_vector;\n        if (eArg.live) {\n            new_vector = to.vector;\n        } else {\n            new_vector = motionutils.calculateVector(to.vector, to.clock.now());\n        }\n\n        /*\n            The nature of the vector change\n        */\n        const delta = new motionutils.MotionDelta(to.old_vector, new_vector);\n\n        /*\n            Sample the state of the other timing object at same time.\n        */\n        let ts = new_vector.timestamp;\n        let other_new_vector = motionutils.calculateVector(other_to.vector, ts);\n\n        /*\n            Reevaluate active state.\n            This is required after any discontinuity of the position (jump),\n            or if the motion stopped without jumping (pause or halt at range\n            restriction)\n        */\n        const events = [];\n        if (delta.posDelta == PosDelta.CHANGE || delta.MoveDelta == MoveDelta.STOP) {\n\n            // make position interval\n            let low = Math.min(new_vector.position, other_new_vector.position);\n            let high = Math.max(new_vector.position, other_new_vector.position);\n            let itv = new Interval(low, high, true, true);\n\n            // new active cues\n            let activeCues = new Map(this._ds.lookup(itv).map(cue => {\n                return [cue.key, cue];\n            }));\n            // exit cues - in old activeCues but not in new activeCues\n            let exitCues = map_difference(this._activeCues, activeCues);\n            // enter cues - not in old activeCues but in new activeCues\n            let enterCues = map_difference(activeCues, this._activeCues);\n            // update active cues\n            this._activeCues = activeCues;\n            // make events\n            for (let cue of exitCues.values()) {\n                events.push({key:cue.key, new:undefined, old:cue});\n            }\n            for (let cue of enterCues.values()) {\n                events.push({key:cue.key, new:cue, old:undefined});\n            }\n\n            // sort events according to general movement direction\n            let direction = movement_direction(new_vector, other_new_vector);\n            BaseSequencer.sort_events(events, direction);\n\n            // event notification\n            this._notifyEvents(events);\n        }\n\n        /*\n            Handle Timing Object Moving\n            - on init both shedules must be updated\n        */\n        if (to == this._toA) {\n            this._schedA.setVector(new_vector);\n        } else if (to == this._toB) {\n            this._schedB.setVector(new_vector);\n        }\n        if (init) {\n            if (other_to == this._toA) {\n                this._schedA.setVector(other_new_vector);\n            } else if (other_to == this._toB) {\n                this._schedB.setVector(other_new_vector);\n            }\n        }\n    };\n\n\n    /***************************************************************\n     SCHEDULE CALLBACK\n    ***************************************************************/\n\n    /*\n        Handling due Events from Schedules\n    */\n    _onScheduleCallback = function(now, endpointItems, schedule) {\n        if (!this._isReady()) {\n            return;\n        }\n\n        /*\n            figure out which timing object was firing\n        */\n        const to = schedule.to;\n        const other_to = (to == this._toA) ? this._toB : this._toA;\n\n        const events = [];\n        endpointItems.forEach(function (item) {\n\n            /*\n                figure out if to (event source) is lower than the other to\n                at time of event\n            */\n            // endpoint\n            let [pos, right, closed, singular] = item.endpoint;\n            // position of other to at time of event\n            let ts = item.tsEndpoint[0];\n            let other_vector = motionutils.calculateVector(other_to.vector, ts);\n            let pos_other = other_vector.position;\n\n            /*\n                Action Code - see sequenceutils\n            */\n            // to role\n            let to_role = (pos < pos_other) ? \"L\" : (pos == pos_other) ? \"S\" : \"R\";\n            // movement direction\n            let to_dir = (item.direction > 0) ? \"R\" : \"L\";\n            // endpoint type\n            let ep_type = (singular) ? \"S\": (right) ? \"R\" : \"L\";\n            // action code, enter, exit, stay, enter-exit\n            let action_code = ActiveMap.get(`${to_role}${to_dir}${ep_type}`);\n\n            /*\n                state of cue\n            */\n            let cue = item.cue;\n            let has_cue = this._activeCues.has(cue.key);\n\n            // filter action code\n            if (action_code == Active.ENTER_EXIT) {\n                /*\n                    both timing objects evaluated to same position\n                    either\n                    1) to is moving and other_to is paused at this point,\n                       implying that the cue STAYS active\n                    or,\n                    2) both are moving. if both are moving in the same\n                    direction - EXIT\n                    opposite direction - ENTER\n                */\n                let other_moving = motionutils.isMoving(other_vector);\n                if (!other_moving) {\n                    // other not moving\n                    action_code = Active.ENTER;\n                } else {\n                    // both moving\n                    let direction = motionutils.calculateDirection(other_vector);                        // movement direction\n                    action_code = (direction != item.direction) ? Active.ENTER : Active.EXIT;\n                }\n            }\n            if (action_code == Active.STAY) {\n                action_code = Active.ENTER;\n            }\n            if (action_code == Active.ENTER && has_cue) {\n                return;\n            }\n            if (action_code == Active.EXIT && !has_cue) {\n                return;\n            }\n\n            // enter or exit\n            if (action_code == Active.ENTER) {\n                // enter\n                events.push({key:cue.key, new:cue, old:undefined});\n                this._activeCues.set(cue.key, cue);\n            } else if (action_code == Active.EXIT) {\n                // exit\n                events.push({key:cue.key, new:undefined, old:cue});\n                this._activeCues.delete(cue.key);\n            }\n        }, this);\n\n        // Events already sorted\n\n        // event notification\n        this._notifyEvents(events);\n    }\n}\n\nexport default DoubleSequencer;\n\n","\n/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// utils\nexport * as utils from './util/utils.js';\nexport * as motionutils from './util/motionutils.js';\nexport {default as endpoint} from './util/endpoint.js';\nexport {default as eventify} from './util/eventify.js';\nexport {default as Interval} from './util/interval.js';\n\n// timing object\nexport {default as TimingObject} from './timingobject/timingobject.js';\nexport {default as SkewConverter} from './timingobject/skewconverter.js';\nexport {default as DelayConverter} from './timingobject/delayconverter.js';\nexport {default as ScaleConverter} from './timingobject/scaleconverter.js';\nexport {default as LoopConverter} from './timingobject/loopconverter.js';\nexport {default as RangeConverter} from './timingobject/rangeconverter.js';\nexport {default as TimeshiftConverter} from './timingobject/timeshiftconverter.js';\n\n// sequencing\nexport {default as Dataset} from './sequencing/dataset.js';\nimport {default as SingleSequencer} from './sequencing/singlesequencer.js';\nimport {default as DoubleSequencer} from './sequencing/doublesequencer.js';\n\n\n/*\n    Common constructor SingeSequencer and DoubleSequencer\n*/\nexport function Sequencer(axis, toA, toB) {\n    if (toB === undefined) {\n        return new SingleSequencer(axis, toA);\n    } else {\n        return new DoubleSequencer(axis, toA, toB);\n    }\n};\n\nexport const version = \"v3.0\";\n"],"names":["all","pred","as","a","isIn","has","map_difference","b","size","Map","filter","key","value","map_intersect","isIterable","obj","Symbol","iterator","array_concat","arrays","options","copy","order","length","total_len","reduce","acc","cur","sort","end","len","first","shift","start","arr","i","object_equals","propName","aProps","Object","getOwnPropertyNames","bProps","docready","Promise","resolve","document","readyState","onReady","removeEventListener","window","addEventListener","bs","n","d","r","isNumber","N","parseFloat","isNaN","create","val","right","closed","singular","Infinity","Error","get_mode","e","undefined","get_order","e1","e2","cmp","order1","order2","diff","toString","mode","equals","rightof","leftof","min","max","IntervalError","[object Object]","message","super","this","name","Relation","freeze","OUTSIDE_LEFT","OVERLAP_LEFT","COVERED","EQUALS","COVERS","OVERLAP_RIGHT","OUTSIDE_RIGHT","MATCH_OUTSIDE","MATCH_INSIDE","MATCH_OVERLAP","MATCH_COVERS","MATCH_ALL","Interval","endpointLow","endpointHigh","low","low_right","low_closed","low_singular","high","high_right","high_closed","high_singular","OUTSIDE","INSIDE","OVERLAP","ALL","lowInclude","highInclude","finite","isFinite","endpoint","p","other","compare","mask","relation","Boolean","includes","_make_interval_cmp","cmpLow","cmpHigh","equalVectors","vector_a","vector_b","pos","position","vel","velocity","acceleration","ts","timestamp","calculateVector","vector","deltaSec","calculateDirection","freshVector","direction","isMoving","RangeState","INIT","OUTSIDE_LOW","OUTSIDE_HIGH","correctRangeState","range","v","checkRange","state","rangeIntersect","t0","deltaLeft","calculateMinPositiveRealSolution","deltaRight","hasRealSolution","x","Math","pow","calculateRealSolutions","sqrt","d1","d2","res","calculatePositiveRealSolutions","calculateDelta","deltaBeforeSec","deltaAfterSec","posInterval_from_timeInterval","timeInterval","t1","t0_closed","t1_closed","vector0","p0","v0","a0","p1","t_extrem","covers_endpoint","p_extrem","timeEndpoint_from_posEndpoint","posEndpoint","close","endpointEvents","posInterval","endpointItems","deltas","tsEndpoint","eventItems","forEach","item","delta","push","MotionDelta","NOOP","CHANGE","NOOP_MOVING","START","STOP","old_vector","new_vector","is_moving","init","PosDelta","MoveDelta","_mc","mct","was_moving","end_vector","start_vector","pct","vel_changed","acc_changed","posDelta","moveDelta","str","Event","publisher","subscriptions","callback","sub","Subscription","init_pending","self","then","eArgs","eventifyInitEventArgs","eArg","trigger","subs","eInfo","ctx","terminated","src","call","err","console","log","idx","indexOf","splice","terminate","event","unsubscribe","eventifyInstance","object","__eventify_eventMap","__eventify_buffer","eventifyPrototype","_prototype","eventifyGetEvent","get","eventifyDefine","set","eventifyTrigger","eventifyTriggerAll","eventifyTriggerAlike","map","triggerItems","ev","buf","buf_len","eventifySubscriptions","on","subscribe","off","EventVariable","_value","prototype","EventBoolean","makePromise","eventObject","conditionFunc","reject","Timeout","timingObject","tid","to","target_ts","arg","now","clock","delay","setTimeout","onTimeout","bind","clearTimeout","performance","offset","Date","getTime","local_clock","tsSec","MasterClock","_vector","eventify","adjust","nowVector","query","skew","rate","InternalProvider","_clock","_range","_callback","_process_update","rest","_old_vector","ExternalProvider","provider","required","prop","checkTimingProvider","_provider","_ready","_provider_clock","_onVectorChange","_onSkewChange","local_ts","current_skew","skew_delta","isReady","live","update","motionutils.checkRange","motionutils.calculateVector","TimingObject","timingsrc","isTimingProvider","__options","timeout","__old_vector","__vector","__range","__timeout","__handleTimeout","__tid","__timingsrc","__sub","__update_events","__ready","__set_timingsrc","ready","motionutils.MotionDelta","isSet","__process","onRangeViolation","__update","ok","tunnel","floor","random","promise","_arg","onUpdateStart","range_change","vector_change","motionutils.equalVectors","__dispatchEvents","__renewTimeout","delete","values","onUpdateDone","moving","motionutils.isMoving","setInterval","clear","timeout_vector","__calculateTimeoutVector","now_vector","motionutils.calculateDelta","__handleEvent","__clear_timingsrc","SkewConverter","_skew","DelayConverter","_delay","_buffer","_timeout","__handleDelayed","due","ScaleConverter","factor","_factor","scale","transform","m","LoopConverter","now_vector_src","_state","new_state","new_range","absolute","special","old_state","is_special_state_change","RangeConverter","__state","onVectorChange","state_changed","TimeshiftConverter","_offset","BinarySearchError","BinarySearch","array","searchElement","currentIndex","currentElement","minIndex","maxIndex","index","binaryIndexOf","isFound","elements","indexes","to_remove","to_insert","indexOfElements","abs","concat","A","Set","approach","arrayLength","batchLength","_update_splice","_update_sort","interval","start_index","end_index","geIndexOf","gtIndexOf","leIndexOf","ltIndexOf","lookupIndexes","slice","removeList","rd_ptr","wr_ptr","rm_ptr","rd_elem","rm_elem","removeCueFromArray","cue","findIndex","_cue","CueBucketIds","getCueBucketId","Delta","INSERT","REPLACE","DELETE","cue_delta","cue_a","cue_b","interval_delta","data_delta","eq","a_interval_defined","b_interval_defined","a_data_defined","data","b_data_defined","utils.object_equals","cue_cmp_forwards","iterval","cue_cmp_backwards","sort_cues","cues","cuess","Dataset","_cueMap","_cueBuckets","cueBucketId","CueBucket","_update_callbacks","events","new","old","has_update_subs","has_remove_subs","has_change_subs","handler","handle","indexof","batchMap","relevanceInterval","current_cue","has_interval","has_data","check","chaining","utils.isIterable","hasOwnProperty","_update_cue","_call_buckets","relevance","_notifyEvents","fromEndpoints","_notify_callbacks","old_cue","new_cue","_item","oldCueBucket","newCueBucket","low_changed","high_changed","remove_needed","add_needed","cue_copy","old_bid","new_bid","del_endpoint","add_endpoint","method","args","cueBucket","utils.array_concat","cueMap","keys","entries","points","bucketInfo","maxLength","_maxLength","_pointMap","_pointIndex","_created","_dirty","point","add","broader_interval","lookup","result","_endpoint","cueSet","Match","match","_mask","_lookup_cues","left_interval","j","removeInSlice","missing","_cues","pft","motionutils.posInterval_from_timeInterval","queueCmp","Schedule","axis","run","queue","callbacks","lookahead","LOOKAHEAD","advance","endpoints","minimum_tsEndpoint","motionutils.endpointEvents","range_ts","motionutils.rangeIntersect","dueEvents","pop","lookup_endpoints","load","next","isNoop","Active","ENTER","STAY","EXIT","ENTER_EXIT","ActiveMap","event_cmp_forwards","event_a","event_b","itv_a","itv_b","event_cmp_backwards","sort_events","BaseSequencer","dataset","_activeCues","_ds","cb","_onDatasetCallback","_ds_cb","add_callback","get_movement_direction","ds","eventMap","enterEvents","changeEvents","exitEvents","is_active","should_be_active","enterCues","remainCues","SingleSequencer","_to","_sub","_onTimingCallback","_sched","_onScheduleCallback","_sched_cb","motionutils.calculateDirection","activeInterval","get_events","_events_from_dataset_events","_events_from_dataset_lookup","exit","change","enter","setVector","itv","activeCues","exitCues","schedule","has_cue","to_dir","ep_type","action_code","movement_direction","now_vector_A","now_vector_B","DoubleSequencer","toA","toB","_toA","_toA_ready","_toB","_toB_ready","to_cb","_subA","_subB","sched_cb","_schedA","_schedA_cb","_schedB","_schedB_cb","_isReady","pos_A","pos_B","other_to","other_new_vector","other_vector","pos_other","to_role","Sequencer","version"],"mappings":"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"}