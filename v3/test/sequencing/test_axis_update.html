<!DOCTYPE html>
<html>
  <head>

    <!--  main -->
    <script type="module">

        import {utils, Interval, Axis} from '../index.js';

        const Delta = Axis.Delta;
        const cue_delta = Axis.cue_delta;
        const equals = utils.object_equals;

        /*
            determine equality for two cues
            <equals> is optional equality function for cue.data
            if not specified simple value equality (==) is used
        */
        function cue_equals(cue_a, cue_b) {
            let delta = cue_delta(cue_a, cue_b);
            return delta.interval == Delta.NOOP && delta.data == Delta.NOOP;
        }


        function assertTrue(val) {
          if (!val) {
            throw new Error("not true: " + val);
          }
        }

        function copy_cue(cue) {
          return {
            key: cue.key,
            interval: cue.interval,
            data: cue.data
          };
        }

        /*
          test all basic update operations
        */
        function test_update() {
          let ax = new Axis();
          let res, init_cue, _init_cue, cue;

          /*
            INSERT
          */

          function test_insert() {
            ax.clear()
            init_cue = undefined;
            cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.INSERT);
            assertTrue(delta.data == Delta.INSERT);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(init_cue, res[0].old))
            // test that resulting new cue is equal to cue
            assertTrue(cue_equals(res[0].new, cue));
          }

          function test_insert_interval() {
            ax.clear()
            init_cue = undefined;
            cue = {key: 1, interval: new Interval(3, 4)}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.INSERT);
            assertTrue(delta.data == Delta.NOOP);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(init_cue, res[0].old))
            // test that resulting new cue is equal to cue
            assertTrue(cue_equals(res[0].new, cue));
          }

          function test_insert_data() {
            ax.clear()
            init_cue = undefined;
            cue = {key: 1, data: {j:"jalla"}}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.NOOP);
            assertTrue(delta.data == Delta.INSERT);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(init_cue, res[0].old))
            // test that resulting new cue is equal to cue
            assertTrue(cue_equals(res[0].new, cue));
          }

          /*
            REPLACE
          */

          function test_replace() {
            ax.clear()
            init_cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}};
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            cue = {key: 1, interval: new Interval(3, 5), data: {j:"palla"}}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.REPLACE);
            assertTrue(delta.data == Delta.REPLACE);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
            // test that resulting new cue is equal to cue
            assertTrue(cue_equals(res[0].new, cue));
          }

          function test_replace_interval_preserve_data() {
            ax.clear()
            init_cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            cue = {key: 1, interval: new Interval(3, 5)}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.REPLACE);
            assertTrue(delta.data == Delta.NOOP);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
            // test that resulting new cue is equal to cue
            assertTrue(cue_equals(res[0].new, cue));
          }

          function test_replace_interval_delete_data() {
            ax.clear()
            init_cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            cue = {key: 1, interval: new Interval(3, 5), data:undefined}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.REPLACE);
            assertTrue(delta.data == Delta.DELETE);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
            // test that resulting new cue is equal to cue
            assertTrue(cue_equals(res[0].new, cue));
          }

          function test_replace_data_preserve_interval() {
            ax.clear()
            init_cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            cue = {key: 1, data: {j:"palla"}}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.NOOP);
            assertTrue(delta.data == Delta.REPLACE);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
            // test that resulting new cue is equal to cue
            assertTrue(cue_equals(res[0].new, cue));
          }

          function test_replace_data_delete_interval() {
            ax.clear()
            init_cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            cue = {key: 1, interval: undefined, data: {j:"palla"}}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.DELETE);
            assertTrue(delta.data == Delta.REPLACE);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
            // test that resulting new cue is equal to cue
            assertTrue(cue_equals(res[0].new, cue));
          }

          /*
            DELETE
          */

          function test_delete_cue() {
            ax.clear()
            init_cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            cue = {key: 1}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 0);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.DELETE);
            assertTrue(delta.data == Delta.DELETE);
            // test that deleted cue is not found in axis
            assertTrue(ax.get(1) == undefined);
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
            // test that reported new cue is undefined
            assertTrue(cue_equals(res[0].new, undefined))
          }

          function test_delete_data_preserve_interval() {
            ax.clear()
            init_cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            cue = {key: 1, data:undefined}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.NOOP);
            assertTrue(delta.data == Delta.DELETE);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
            // test that resulting new cue preserves interval
            assertTrue(res[0].new.interval.equals(_init_cue.interval));
            // test that resulting new cue deletes data
            assertTrue(res[0].data == undefined);
          }

          function test_delete_interval_preserve_data() {
            ax.clear()
            init_cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            cue = {key: 1, interval: undefined}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.DELETE);
            assertTrue(delta.data == Delta.NOOP);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
            // test that resulting new cue deletes interval
            assertTrue(res[0].new.interval == undefined);
            // test that resulting new cue preserves data
            assertTrue(cue_equals(res[0].data, init_cue.data));
          }

          function test_delete_nonexistent() {
            ax.clear()
            init_cue = undefined;
            cue = {key: 1}
            res = ax.update(cue)
            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 0);

            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.NOOP);
            assertTrue(delta.data == Delta.NOOP);
          }

          function test_delete_nonexistent_interval_data() {
            ax.clear()
            init_cue = undefined;
            cue = {key: 1, interval:undefined, data:undefined}
            res = ax.update(cue)
            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 0);

            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.NOOP);
            assertTrue(delta.data == Delta.NOOP);
          }

          function test_delete_nonexistent_interval() {
            ax.clear()
            init_cue = undefined;
            cue = {key: 1, interval:undefined}
            res = ax.update(cue)
            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 0);

            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.NOOP);
            assertTrue(delta.data == Delta.NOOP);
          }

          function test_delete_nonexistent_data() {
            ax.clear()
            init_cue = undefined;
            cue = {key: 1, data:undefined}
            res = ax.update(cue)
            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 0);

            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.NOOP);
            assertTrue(delta.data == Delta.NOOP);
          }

          /*
            NOOP
          */

          function test_noop() {
            // test replace interval - not preserve
            ax.clear()
            init_cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}}
            ax.update(init_cue);
            cue = {key: 1, interval: new Interval(3, 4), data: {j:"jalla"}}
            res = ax.update(cue)

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);

            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.NOOP);
            assertTrue(delta.data == Delta.NOOP);
          }


          /*
            RUN
          */


          test_insert();
          test_insert_interval();
          test_insert_data();

          test_replace();
          test_replace_interval_preserve_data();
          test_replace_interval_delete_data();
          test_replace_data_preserve_interval();
          test_replace_data_delete_interval();

          test_delete_cue();
          test_delete_data_preserve_interval();
          test_delete_interval_preserve_data();
          test_delete_nonexistent();
          test_delete_nonexistent_interval();
          test_delete_nonexistent_data();
          test_delete_nonexistent_interval_data();

          test_noop();

          console.log("done test update");

        }

        /*
          test multiple updates regarding the same cue
        */
        function test_update_multiple() {


          let res, init_cue, _init_cue, cues;
          let ax = new Axis();

          /*
            verify that original data is not preserved when interval is given
            after delete
          */
          function test_delete_first() {
            ax.clear();
            init_cue = {key: 1, interval: new Interval(3, 4), data:{j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            cues = [
              {key: 1},
              {key: 1, interval: new Interval(3, 5)}
            ];
            res = ax.update(cues);
            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.REPLACE);
            assertTrue(delta.data == Delta.DELETE);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
          }

          /*
            verify that delete last does the job
          */
          function test_delete_last() {
            ax.clear();
            init_cue = {key: 1, interval: new Interval(3, 4), data:{j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);

            // test delete last
            cues = [
              {key: 1, interval: new Interval(3, 5)},
              {key: 1}
            ];
            res = ax.update(cues);
            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 0);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.DELETE);
            assertTrue(delta.data == Delta.DELETE);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
          }


 /*
            verify that original data is not preserved when interval is given
            after delete
          */
          function test_delete_first_no_chaining() {
            ax.clear();
            init_cue = {key: 1, interval: new Interval(3, 4), data:{j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            cues = [
              {key: 1},
              {key: 1, interval: new Interval(3, 5)}
            ];
            res = ax.update(cues, {chaining:false});
            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.INSERT);
            assertTrue(delta.data == Delta.NOOP);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to previous cue
            assertTrue(cue_equals(undefined, res[0].old))
          }

          /*
            verify that delete last does the job
          */
          function test_delete_last_no_chaining() {
            ax.clear();
            init_cue = {key: 1, interval: new Interval(3, 4), data:{j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);

            // test delete last
            cues = [
              {key: 1, interval: new Interval(3.5, 5)},
              {key: 1}
            ];
            res = ax.update(cues, {chaining:false});
            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 0);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.DELETE);
            assertTrue(delta.data == Delta.DELETE);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to the previous cue
            assertTrue(cue_equals(cues[0], res[0].old))
          }




          /*
            verify that data is preserved through multiple interval replacements
          */
          function test_preserve_data() {
            ax.clear();
            init_cue = {key: 1, interval: new Interval(3, 4), data:{j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);

            // test preserve data
            cues = [
              {key: 1, interval: new Interval(3, 5)},
              {key: 1, interval: new Interval(3, 6)}
            ];
            res = ax.update(cues);

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.REPLACE);
            assertTrue(delta.data == Delta.NOOP);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            // test that reported old cue is equal to initial cue
            assertTrue(cue_equals(_init_cue, res[0].old))
            // test that resulting interval is from second cue
            assertTrue(res[0].new.interval.equals(cues[1].interval))
            // test that resulting data is from original cue
            assertTrue(equals(res[0].new.data, _init_cue.data));
          }

          function test_preserve_interval() {
            ax.clear();
            init_cue = {key: 1, interval: new Interval(3, 4), data:{j:"jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);

            // test preserve interval
            cues = [
              {key: 1, data: {}},
              {key: 1, data: {j:"palla"}}
            ];
            res = ax.update(cues);

            // test sizes
            assertTrue(res.length == 1);
            assertTrue(ax.size == 1);
            // test delta values
            let delta = cue_delta(res[0].old, res[0].new);
            assertTrue(delta.interval == Delta.NOOP);
            assertTrue(delta.data == Delta.REPLACE);
            // test that reported new cue is equal to cue found in axis
            assertTrue(cue_equals(ax.get(1), res[0].new))
            assertTrue(cue_equals(_init_cue, res[0].old))
            // test that resulting interval is from original cue
            assertTrue(res[0].new.interval.equals(_init_cue.interval))
            // test that resulting data is from second cue
            assertTrue(equals(res[0].new.data, cues[1].data));
          }

          test_delete_first();
          test_delete_last();
          test_delete_first_no_chaining();
          test_preserve_data();
          test_preserve_interval();
          test_delete_last_no_chaining();
          console.log("done test update multiple")
        }


        /*
          test that effects of update are picked up by lookup
        */

        function test_update_lookup() {

          const ax = new Axis();
          let init_cue, _init_cue, cue, cues;
          const lookup_interval = new Interval(1,4);

          /*
            Test that data update is reflected by both lookup and
            get.

          */

          function test_lookup_after_data_update() {

            ax.clear();

            init_cue = {key:1, interval: new Interval(2,3), data: {jalla: "jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);

            // update data
            cue = {key:1, data: {palla: "palla"}};
            ax.update(cue);

            cues = ax.lookup(lookup_interval);

            // test that cue object is the same as the initial update
            assertTrue(cues[0] === init_cue);
            assertTrue(cues[0] === ax.get(1));
            // test that cue.data is updated
            assertTrue(equals(cues[0].data, cue.data));
            // test that get returns same cue
            assertTrue(cue_equals(cues[0], ax.get(1)));
          }

          /*
            Test that we can move cue by updating the interval,
            this way making it visible and invisible for lookup.
          */


          function test_lookup_after_interval_update() {

            ax.clear();

            init_cue = {key:1, interval: new Interval(2,3), data: {jalla: "jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);

            // make cue invisible by shifting right
            ax.update({key:1, interval: new Interval(5,7)});
            cues = ax.lookup(lookup_interval);
            assertTrue(cues.length == 0);

            // make cue visible by shifting left
            cue = {key:1, interval: new Interval(3,5)};
            ax.update(cue);
            cues = ax.lookup(lookup_interval);

            assertTrue(cues.length == 1);

            // test that get returns same cue
            assertTrue(cue_equals(cues[0], ax.get(1)));
            assertTrue(cues[0] == init_cue);
            assertTrue(cue.interval.equals(cues[0].interval));
          }



          /*
            by stretching a cue it will end up in a new bucket
          */
          function test_lookup_after_stretch_update() {

            ax.clear();

            init_cue = {key:1, interval: new Interval(2,3), data: {jalla: "jalla"}}
            _init_cue = copy_cue(init_cue)
            ax.update(init_cue);
            ax.integrity()

            let cues = ax.lookup(new Interval(10,20));
            assertTrue(cues.length == 0);

            ax.update({key:1, interval: new Interval(2,13)});
            ax.integrity()

            cues = ax.lookup(new Interval(10,20));
            assertTrue(cues.length == 1);
          }


          test_lookup_after_data_update();
          test_lookup_after_interval_update();
          test_lookup_after_stretch_update();

          console.log("done test update lookup");
        }

        /*
          test change event
        */

        function test_event () {
          let ax = new Axis();
          let flag = false;

          let cues = [];
          for (let i=0; i<100; i++) {
            cues.push({key: i.toString(), interval: new Interval(i, i+1)});
          }

          // events event for the entire batch
          ax.on("update", function (eItems) {
            assertTrue(eItems.length == cues.length);
            flag = true;
          });

          // update
          ax.update(cues)

          setTimeout(e => {
            assertTrue(flag);
            console.log("done test event");
          }, 0);

        };


        var run = function () {
          test_update();
          test_update_multiple();
          test_update_lookup();
          test_event();
        };

        if (document.readyState === "complete") run();
        else window.onload = run;

    </script>
  </head>
  <body>
    <h1>Test Axis</h1>
  </body>
</html>
